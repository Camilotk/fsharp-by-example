<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>F# by example</title><link>https://camilotk.github.io/fsharp-by-example/</link><description>Recent content on F# by example</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 10 Nov 2022 10:31:11 +0300</lastBuildDate><atom:link href="https://camilotk.github.io/fsharp-by-example/index.xml" rel="self" type="application/rss+xml"/><item><title>Hello World in F#</title><link>https://camilotk.github.io/fsharp-by-example/chapters/hello-world/</link><pubDate>Thu, 10 Nov 2022 10:31:11 +0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/hello-world/</guid><description>The first program that anyone will always do first when starting to learn a new programming language is a program that prints &amp;ldquo;hello world&amp;rdquo; in a terminal. We&amp;rsquo;ll do that for practice, to get used to the language and environment.
What you will need for this? F# installed on your machine, if you don&amp;rsquo;t have it yet, this link will help you. A UTF-8 compatible text editor for you to edit the code, if you don&amp;rsquo;t have any preference we recommend Visual Studio Code.</description></item><item><title>Using REPL</title><link>https://camilotk.github.io/fsharp-by-example/chapters/using-repl/</link><pubDate>Sun, 22 Jan 2023 22:01:29 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/using-repl/</guid><description>We&amp;rsquo;ll have a lot of code examples along this tutorial, for better understanding we recommend you to use the REPL.
What is REPL? The REPL (Read-Eval-Print Loop) tool in F# allows users to quickly and easily test code snippets and evaluate expressions. This can be especially useful for new users, as it allows them to quickly experiment and learn the language without the need to write and run full-fledged programs. Additionally, the REPL provides immediate feedback, making it easier to identify and correct errors in code.</description></item><item><title>Variables</title><link>https://camilotk.github.io/fsharp-by-example/chapters/variables/</link><pubDate>Sun, 22 Jan 2023 12:22:06 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/variables/</guid><description>In this first part we will be discussing how to create, set, and use variables in F#. Variables are a fundamental concept in programming and are used to store and manipulate data. In F#, variables are immutable by default, which means that their value cannot be modified once they are set. This makes F# a functional programming language and it helps to improve the program&amp;rsquo;s performance and predictability.
Creating variables In F#, variables are created using the let keyword.</description></item><item><title>Immutability</title><link>https://camilotk.github.io/fsharp-by-example/chapters/immutability/</link><pubDate>Fri, 27 Jan 2023 13:11:15 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/immutability/</guid><description>In summary, immutability in F# refers to the fact that the value of a variable cannot be changed once it is set. This can help prevent a number of problems that can occur in other languages when working with mutable variables, such as concurrent access, side effects, and debugging.
Concurrent access: When multiple threads have access to a mutable variable, it can lead to race conditions where different threads try to access and change the variable at the same time.</description></item><item><title>Functions</title><link>https://camilotk.github.io/fsharp-by-example/chapters/functions/</link><pubDate>Sat, 21 Jan 2023 22:22:09 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/functions/</guid><description>F# is a functional programming language that allows developers to create powerful and expressive code. One of the key features of F# is its support for functions, which are used to perform specific tasks and return a value. In this chapter, we will explore the basics of functions in F# and how they can be used to create reusable and composable code.
Defining functions in F# In F#, a function is defined using the keyword let followed by the name of the function, a list of parameters, and the value or expression that the function will return.</description></item><item><title>Lambda Functions</title><link>https://camilotk.github.io/fsharp-by-example/chapters/lambda-functions/</link><pubDate>Sun, 22 Jan 2023 22:05:50 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/lambda-functions/</guid><description>In F#, lambda functions - or if you prefer, anonymous functions - are defined using the fun keyword. These functions are useful for creating small, one-time-use functions that don&amp;rsquo;t need to be named. They can be passed as arguments to other functions, and can be used to create higher-order functions.
How to create lambda functions A lambda function is a special type of anonymous function that can be used to create higher-order functions.</description></item><item><title>Recursion</title><link>https://camilotk.github.io/fsharp-by-example/chapters/recursion/</link><pubDate>Sun, 22 Jan 2023 22:05:57 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/recursion/</guid><description>Recursion is a programming technique in which a function calls itself to solve a problem. It is a powerful tool that allows for elegant and efficient solutions to many types of problems. In this chapter, we will explore recursion in F# and how it can be used to solve problems.
Introduction to recursion in F# For example, the factorial function below that calculates the factorial of a given number is recursive.</description></item><item><title>Tail Call Optimization</title><link>https://camilotk.github.io/fsharp-by-example/chapters/tail-call-optimization/</link><pubDate>Fri, 27 Jan 2023 13:18:38 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/tail-call-optimization/</guid><description>Efficiency of Recursion in F# One of the key benefits of using recursion in F# is its optimized handling of recursive functions. Unlike languages such as C#, F# is designed with recursion in mind and includes specific optimizations to make recursive functions more efficient.
One of the main optimizations implemented in F# is tail call optimization. This optimization allows the compiler to reuse the current stack frame, rather than creating a new one for each recursive call, significantly reducing the amount of memory used and preventing stack overflow errors.</description></item><item><title>Composition</title><link>https://camilotk.github.io/fsharp-by-example/chapters/composition/</link><pubDate>Sun, 22 Jan 2023 22:06:09 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/composition/</guid><description>Function composition is the process of combining two or more functions to create a new function.
Composition operator In F#, we can use the &amp;gt;&amp;gt; operator to compose functions. The &amp;gt;&amp;gt; operator takes the output of the left-hand function and uses it as the input for the right-hand function.
For example, let&amp;rsquo;s say we have two functions, f and g, that take an integer as input and return an integer as output.</description></item><item><title>Pipeline operator</title><link>https://camilotk.github.io/fsharp-by-example/chapters/pipe/</link><pubDate>Sun, 22 Jan 2023 22:06:09 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/pipe/</guid><description>F# also has pipeline operators, or pipe operators, which allow us to chain function calls together in a readable way. The pipeline operator |&amp;gt; takes the output of the expression on the left-hand side and uses it as the input for the function on the right-hand side.
For example, let&amp;rsquo;s say we have a function f that takes an integer as input and returns an integer as output. We can call this function and pass in the result of another expression using the pipeline operator:</description></item><item><title>Namespaces</title><link>https://camilotk.github.io/fsharp-by-example/chapters/namespaces/</link><pubDate>Fri, 27 Jan 2023 11:52:52 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/namespaces/</guid><description>In F#, a namespace is a container for types, values, and modules. It is used to organize and group related items together, and to prevent naming collisions between items with the same name.
F# uses a hierarchical naming system, where namespaces are separated by dots. For example, the System namespace contains the Console module, which in turn contains the WriteLine function. To access the WriteLine function, we would use the fully-qualified name System.</description></item><item><title>Nested Namespaces</title><link>https://camilotk.github.io/fsharp-by-example/chapters/nested-namespaces/</link><pubDate>Fri, 27 Jan 2023 13:23:31 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/nested-namespaces/</guid><description>In F#, it is possible to organize code within namespaces in a hierarchical manner by using nested namespaces. A nested namespace is a namespace that is defined within another namespace.
To declare a nested namespace, the keyword namespace is used followed by the identifier of the parent namespace, and then the nested namespace is defined using the namespace keyword again followed by the identifier of the nested namespace.
For example:</description></item><item><title>Modules</title><link>https://camilotk.github.io/fsharp-by-example/chapters/modules/</link><pubDate>Fri, 27 Jan 2023 11:52:56 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/modules/</guid><description>Modules are a way to organize and group related functions and values in F#. They are similar to namespaces in other languages, but with some key differences.
What is a module? A module in F# is a unit of code that can contain type declarations, function definitions, and value definitions. It provides a way to organize and structure your code into logical units, making it easier to maintain and reuse your code.</description></item><item><title>Organization</title><link>https://camilotk.github.io/fsharp-by-example/chapters/organization/</link><pubDate>Thu, 02 Feb 2023 15:40:33 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/organization/</guid><description>Code organization is a crucial aspect of software development and it is essential to choose the right tools to ensure that your code is well-structured, maintainable, and scalable. In F#, modules and namespaces are two of the tools that are commonly used to achieve code organization.
Choosing between Modules and Namespaces When deciding between using modules or namespaces for code organization, it is important to consider the purpose of each tool and to choose the one that best fits your needs.</description></item><item><title>Types</title><link>https://camilotk.github.io/fsharp-by-example/chapters/types/</link><pubDate>Thu, 02 Feb 2023 19:30:17 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/types/</guid><description>F# is a statically typed language, meaning that the type of a value must be known at compile-time. F# has several built-in types that can be used to represent values in your programs. We&amp;rsquo;ll explore the basic types in F# and how to use them.
Numbers F# supports several numeric types such as integers (int, long, byte), floating-point numbers (float), and decimal numbers (decimal). The following table shows the size and range of values for each type:</description></item><item><title>Unit</title><link>https://camilotk.github.io/fsharp-by-example/chapters/unit/</link><pubDate>Thu, 02 Feb 2023 19:36:07 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/unit/</guid><description>F# is a functional programming language that is commonly used for developing applications in a wide range of domains. One of the core concepts in F# is the concept of a unit type, which is represented by the type unit.
let myUnit : unit = () It&amp;rsquo;s important to note that the unit type only has one possible value, which is (), so declaring a variable of type unit is not very useful in practice.</description></item><item><title>Casting</title><link>https://camilotk.github.io/fsharp-by-example/chapters/casting/</link><pubDate>Thu, 02 Feb 2023 19:36:13 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/casting/</guid><description>Type casting in F# is a process of converting one type of value to another type of value. This can be useful in situations where the type of a value needs to be changed in order to be used in a specific context. There are several ways to perform type casting in F#, including explicit casting, implicit casting, and type coercion.
Explicit Casting Explicit casting in F# involves explicitly specifying the target type for a value, using the :&amp;gt; operator.</description></item><item><title>Boolean Operators</title><link>https://camilotk.github.io/fsharp-by-example/chapters/boolean-operators/</link><pubDate>Thu, 02 Feb 2023 19:36:31 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/boolean-operators/</guid><description>Boolean operators are used to perform logical operations on Boolean values (i.e., true and false). F# provides several boolean operators that can be used to test conditions, compare values, and perform other types of operations. In this chapter, we will discuss the different boolean operators in F# and how to use them in your code.
AND The logical AND operator (&amp;amp;&amp;amp;) is used to combine two conditions. The result of the AND operation is true if both conditions are true, and false if either condition is false.</description></item><item><title>Strings</title><link>https://camilotk.github.io/fsharp-by-example/chapters/strings/</link><pubDate>Thu, 02 Feb 2023 19:36:40 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/strings/</guid><description>In F#, a string is a sequence of Unicode characters enclosed in double quotes. Strings are often used to store and manipulate text data, such as names, addresses, and messages.
String Literal A string literal is a string that is directly specified in the source code. String literals can be defined by enclosing the text in double quotes:
let name = &amp;#34;John Doe&amp;#34; String Interpolation String interpolation is a feature in F# that allows you to embed expressions within a string literal.</description></item><item><title>String Manipulation</title><link>https://camilotk.github.io/fsharp-by-example/chapters/string-manipulation/</link><pubDate>Thu, 02 Feb 2023 23:43:23 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/string-manipulation/</guid><description>F# provides several functions and methods for string manipulation.
Split The split function splits a string into an array of substrings based on a specified separator:
let sentence = &amp;#34;OCaml, Standard ML, F#&amp;#34; let names = sentence.Split &amp;#34;,&amp;#34; // val names: string array = [|&amp;#34;OCaml&amp;#34;; &amp;#34; Standard ML&amp;#34;; &amp;#34; F#&amp;#34;|] Replace The replace function replaces all occurrences of a specified string with another string:
let sentence = &amp;#34;OCaml, Standard ML, F#&amp;#34; let updatedSentence = sentence.</description></item><item><title>Lists</title><link>https://camilotk.github.io/fsharp-by-example/chapters/list/</link><pubDate>Fri, 17 Feb 2023 18:59:04 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/list/</guid><description>Lists are a commonly used data structure in F# and they provide a way to store sequences of values. In F#, lists are immutable, meaning that their contents cannot be changed after they are created. This feature makes them well-suited for functional programming.
Creating Lists In F#, lists can be created in several ways. The simplest way to create a list is to use square brackets and separate the elements with semicolons.</description></item><item><title>List Module</title><link>https://camilotk.github.io/fsharp-by-example/chapters/list-module/</link><pubDate>Fri, 17 Feb 2023 21:02:03 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/list-module/</guid><description>In addition to the basic list operations that we covered in the previous chapter, F# also provides a List module with many useful functions for working with lists. This module provides a variety of functions for manipulating lists and performing common operations.
Common Functions There are many other functions in the List module that are beyond the scope of this chapter, but some notable ones include:
append Concatenates two lists together</description></item><item><title>Range Operator</title><link>https://camilotk.github.io/fsharp-by-example/chapters/range-operator/</link><pubDate>Fri, 17 Feb 2023 21:46:45 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/range-operator/</guid><description>The range operator .. is used to declare lists of ordered sequence values.
Basic Usage Using the range operator, we can quickly create a list of ordered sequence values with a single line of code. For instance, the following F# code creates a list of integers ranging from 1 to 5:
[1..5] // =&amp;gt; [1; 2; 3; 4; 5] Similarly, we can create a list of characters ranging from &amp;lsquo;a&amp;rsquo; to &amp;lsquo;f&amp;rsquo;:</description></item><item><title>List Comprehensisions</title><link>https://camilotk.github.io/fsharp-by-example/chapters/list-comprehensisions/</link><pubDate>Fri, 17 Feb 2023 22:17:28 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/list-comprehensisions/</guid><description>List Comprehensions is a more powerful way of constructing lists in F# that is derived from the mathematical concept of &amp;ldquo;set comprehensions&amp;rdquo; or &amp;ldquo;Set-builder notation&amp;rdquo;. A set comprehension is a list defined from a set of rules that define the properties that its elements must satisfy.
Any comprehension has at least three parts:
Collection: the source of the values that will be in the list, in F# usually a range or a list.</description></item><item><title>Arrays</title><link>https://camilotk.github.io/fsharp-by-example/chapters/arrays/</link><pubDate>Fri, 17 Feb 2023 22:26:54 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/arrays/</guid><description>Arrays in F# are similar to lists but have different performance characteristics and the ability to index any value directly in the array. In this chapter, we will cover the syntax of arrays and how they differ from lists.
Creating Arrays To create an array, we use the same syntax as for lists, but with pipes instead of square brackets:
[|1; 2; 3|] // =&amp;gt; [|1; 2; 3|] The result of the code above is an array containing the values 1, 2, and 3.</description></item><item><title>Maps</title><link>https://camilotk.github.io/fsharp-by-example/chapters/maps/</link><pubDate>Fri, 17 Feb 2023 23:46:46 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/maps/</guid><description>The map function is a common function used in many functional programming languages, including F#. It is used to transform the elements of a collection using a given function, producing a new collection with the same length but with each element transformed by the given function.
Syntax The syntax of the map function in F# is as follows:
List.map (function) list Array.map (function) array Here, List.map and Array.map are the two versions of the function, and function is the function used to transform the elements of the collection.</description></item><item><title>Filter</title><link>https://camilotk.github.io/fsharp-by-example/chapters/filter/</link><pubDate>Sat, 18 Feb 2023 00:05:22 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/filter/</guid><description>In F#, the filter function allows you to remove elements from a sequence that do not match a specified condition. The resulting sequence only contains elements that satisfy the condition.
Syntax The syntax for filter is as follows:
filter (predicate: &amp;#39;a -&amp;gt; bool) (list: &amp;#39;a list) : &amp;#39;a list where:
predicate is a function that takes an element of type generic - we&amp;rsquo;ll see that - and returns a boolean value.</description></item><item><title>Discriminated Union</title><link>https://camilotk.github.io/fsharp-by-example/chapters/discriminated-union/</link><pubDate>Sat, 18 Mar 2023 15:28:23 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/discriminated-union/</guid><description>Discriminated Union in F# In F#, programmers are used to defining types to structure data, but what if types could define a set of choices? A Discriminated Union is a type that can have a certain set of cases, and the value of a Discriminated Union must be one of those cases that were defined. Because the representation of a Discriminated Union is the sum of all its cases, it is also known as a Sum Type, corresponding to types such as products in tuples.</description></item><item><title>Structural Equality</title><link>https://camilotk.github.io/fsharp-by-example/chapters/equality/</link><pubDate>Sat, 18 Mar 2023 17:04:26 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/equality/</guid><description>Structural Equality in F# vs. Referential Equality in C# In F#, values are compared using structural equality, which means that two values are considered equal if they have the same structure and contain the same data. This is different from the referential equality used in other languages such as C#, where two objects are considered equal only if they refer to the same memory location.
To demonstrate this difference, let&amp;rsquo;s compare two F# records using the = operator:</description></item><item><title>Pattern Matching</title><link>https://camilotk.github.io/fsharp-by-example/chapters/pattern-matching/</link><pubDate>Sat, 18 Mar 2023 16:53:06 -0300</pubDate><guid>https://camilotk.github.io/fsharp-by-example/chapters/pattern-matching/</guid><description>Pattern Matching Pattern matching is a powerful feature in functional programming languages that allows you to match a value or data structure against a set of patterns and execute the corresponding code block based on the match. It is a declarative and expressive way of branching code based on data values, and it can be used to simplify complex conditional logic.
In F#, pattern matching is a first-class citizen, which means it is deeply integrated into the language syntax and semantics.</description></item></channel></rss>