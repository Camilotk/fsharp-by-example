[{"id":0,"href":"/fsharp-by-example/chapters/hello-world/","title":"Hello World in F#","parent":"Chapters","content":"The first program that anyone will always do first when starting to learn a new programming language is a program that prints \u0026ldquo;hello world\u0026rdquo; in a terminal. We\u0026rsquo;ll do that for practice, to get used to the language and environment.\nWhat you will need for this? F# installed on your machine, if you don\u0026rsquo;t have it yet, this link will help you. A UTF-8 compatible text editor for you to edit the code, if you don\u0026rsquo;t have any preference we recommend Visual Studio Code. Know how to use the terminal in your operating system, and how to navigate around it. Create the project We will create a console project to do this. To do it we will enter to the folder in our terminal where we want to create this project and enter the command.\n\u0026gt; dotnet new console -lang F# -o Hello The \u0026gt; marker is to indicate that this command should be run on terminal. It\u0026rsquo;s the same as $ for Linux and Mac.\nThis will create a folder \u0026ldquo;Hello\u0026rdquo; with our main project. Inside this folder we will have two files:\nHello.fsproj: That contains the project configuration. Program.fs: That contains our F# code. If we open the \u0026ldquo;Program.fs\u0026rdquo; file we will see: // For more information see https://aka.ms/fsharp-console-apps printfn \u0026#34;Hello from F#\u0026#34; And that\u0026rsquo;s the code that prints \u0026ldquo;Hello from F#\u0026rdquo; in console! The \u0026ldquo;Hello World\u0026rdquo; program is also the example of code of every new F# project.\nUnderstanding this code The first line is a comment, which means that the rest of the code in the line will not be executed. Any code in a line starting with // or between (* ... *) is ignored and not executed. We use it to add information about the code for other programmers that will eventually work in this code. In this case, a message from Microsoft about where we can find more information about console apps.\nThe second line starts with a function. For now, you can think of it as \u0026ldquo;commands\u0026rdquo; as we\u0026rsquo;ll see it next. The printfn function receives a message in String (any text between \u0026quot;...\u0026quot;) and prints it in console.\nChanging the program As we don\u0026rsquo;t need the comment since it will not be executed, we can just delete this line. And, as we want to print \u0026ldquo;Hello World\u0026rdquo; and not \u0026ldquo;Hello from F#!\u0026rdquo;, we can change the value to get what we want.\nChange Program.fs to:\nprintfn \u0026#34;Hello World\u0026#34; Compiling the project After changing the message and before we execute our program, we have to compile it. You can think of compilation as the process that translates your code into code that the computer understands. To do this, just run the command in your terminal:\n\u0026gt; dotnet build For linux users:\nAdd to your .bashrc the flag `export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1` in case of some error at build process. Run the project Now we can run the project, for do it just enter in your terminal the command:\n\u0026gt; dotnet run And you should see \u0026ldquo;Hello World\u0026rdquo; printed in your terminal.\nCongratulations! You done your first F# program.\nGoing to the next level We did the \u0026ldquo;Hello World\u0026rdquo; program, but now we can upgrade it to display \u0026ldquo;Hello\u0026rdquo; for any value so it would work with \u0026ldquo;from F#\u0026rdquo; or \u0026ldquo;World\u0026rdquo; as we want. To do this we will change the printfn function to print formatted text passing a specifier that will be replaced for the message we want.\nSo we\u0026rsquo;ll change our Program.fs to: printfn \u0026#34;Hello %s\u0026#34; \u0026#34;World\u0026#34;\nAnd then build and run it again!\nNow if we want \u0026ldquo;from F#\u0026rdquo; instead \u0026ldquo;World\u0026rdquo; we can change to: So we\u0026rsquo;ll change our Program.fs to: printfn \u0026#34;Hello %s\u0026#34; \u0026#34;from F#\u0026#34;\nNow, if we build and run again, we should see the original message.\nA taste of a statically typed language F# is different from how some other languages works with Types. This means that each piece of information has to be from the expected type in order to work. For example, the %s specifier expects a String type (a message between \u0026quot;...\u0026quot;) if we try to pass a number, for example 42, we will get an error.\nTry doing this, passing 42 as the message: printfn \u0026#34;Hello %s\u0026#34; 42\nIf you try to build this program, you\u0026rsquo;ll get the error:\nerror FS0001: This expression was expected to have type \u0026#39;string\u0026#39; but here has type \u0026#39;int\u0026#39; [.../Hello/Hello.fsproj] The error message is telling us that we should pass a \u0026ldquo;String\u0026rdquo; for this function, but we\u0026rsquo;re passing an \u0026ldquo;int\u0026rdquo; (an \u0026ldquo;Integer\u0026rdquo; number). Our program didn\u0026rsquo;t even produce a new build. We will only be able to execute the code when we fix it by passing the correct value.\nThis will help us to avoid mistakes and errors in our programs. By checking all our errors and enforcing each command to receive the correct parameters, F# will help us to write programs that have less bugs and errors.\n"},{"id":1,"href":"/fsharp-by-example/chapters/using-repl/","title":"Using REPL","parent":"Chapters","content":"We\u0026rsquo;ll have a lot of code examples along this tutorial, for better understanding we recommend you to use the REPL.\nWhat is REPL? The REPL (Read-Eval-Print Loop) tool in F# allows users to quickly and easily test code snippets and evaluate expressions. This can be especially useful for new users, as it allows them to quickly experiment and learn the language without the need to write and run full-fledged programs. Additionally, the REPL provides immediate feedback, making it easier to identify and correct errors in code. Overall, the use of the REPL can greatly facilitate the learning process and make it more interactive and efficient.\nHow to use it on terminal You can use it on terminal, even in the integrated terminal of Visual Studio Code following this steps:\nOpen a terminal window and navigate to the directory where you want to run your F# code. Type dotnet fsi to start the F# REPL. You should see the F# prompt, which is \u0026ldquo;\u0026gt;\u0026rdquo;. Type the code you want to execute and press \u0026ldquo;Enter\u0026rdquo;. For example, to print \u0026ldquo;Hello, World!\u0026rdquo; to the console, type: \u0026gt; printfn \u0026#34;Hello, World!\u0026#34;;; Note that you need to use \u0026ldquo;;;\u0026rdquo; to indicate the end of the expression, which is different from the F# Interactive window in Visual Studio.\nThe F# REPL will evaluate the expression and return the result, just like in the F# Interactive window. How to use it on Visual Studio You can use it on Visual Studio following this steps:\nOpen the F# Interactive window in Visual Studio by selecting \u0026ldquo;View\u0026rdquo; \u0026gt; \u0026ldquo;Other Windows\u0026rdquo; \u0026gt; \u0026ldquo;F# Interactive\u0026rdquo; or by using the keyboard shortcut \u0026ldquo;Ctrl+Alt+F\u0026rdquo; Type the code you want to execute in the F# Interactive window and press \u0026ldquo;Enter\u0026rdquo;. For example, to print \u0026ldquo;Hello, World!\u0026rdquo; to the console, type: printfn \u0026#34;Hello, World!\u0026#34; The F# Interactive will evaluate the expression and return the result, in this case it will print \u0026ldquo;Hello, World!\u0026rdquo; in the console. Script files .fsx files are F# script files, which allow you to write and execute F# code without the need to create a full-fledged project or solution. These files are typically used for small, self-contained scripts or for prototyping and experimentation.\nWhen you execute an .fsx file, the F# compiler will run through the code in the file and execute any statements or expressions that it contains. This allows you to write and run code snippets quickly, without the need to set up a full project or solution.\nOne of the main advantages of using .fsx files is that they allow for a more interactive and iterative development process. You can quickly test and experiment with different ideas, and make changes to your code without the need to rebuild a full project.\nAdditionally, .fsx files can be useful for automating tasks, such as data processing or code generation. You can write a script that performs a specific task, and then run it as needed to automate the process.\nYou can also use .fsx files in conjunction with the F# REPL, by using the \u0026ldquo;#load\u0026rdquo; command to load the script file and execute it. This allows you to test and run your code snippets interactively and to test your functions, modules and types before you include them in your project.\n\u0026gt; #load \u0026#34;./your_script.fsx\u0026#34;;; Overall, .fsx files are a powerful tool that can greatly facilitate the development process in F# and make it more interactive and efficient.\n"},{"id":2,"href":"/fsharp-by-example/chapters/variables/","title":"Variables","parent":"Chapters","content":"In this first part we will be discussing how to create, set, and use variables in F#. Variables are a fundamental concept in programming and are used to store and manipulate data. In F#, variables are immutable by default, which means that their value cannot be modified once they are set. This makes F# a functional programming language and it helps to improve the program\u0026rsquo;s performance and predictability.\nCreating variables In F#, variables are created using the let keyword. The basic syntax for creating a variable is as follows:\nlet variable_name = value For example, to create a variable called \u0026ldquo;x\u0026rdquo; and set its value to 5, we would use the following code:\nlet x = 5 You can also create a variable and define its type using the \u0026ldquo;:\u0026rdquo; operator, like this:\nlet x : int = 5 Setting Variables In F#, variables are set using the \u0026ldquo;let\u0026rdquo; keyword, followed by the variable name, an equal sign (=), and the value to be assigned to the variable. For example:\nlet x = 5 This creates a new variable named \u0026ldquo;x\u0026rdquo; and assigns the value of 5 to it.\nOnce a variable is set, its value cannot be modified directly. This is because F# variables are immutable by default, which means that their value cannot be changed once they are set.\n"},{"id":3,"href":"/fsharp-by-example/chapters/immutability/","title":"Immutability","parent":"Chapters","content":"In summary, immutability in F# refers to the fact that the value of a variable cannot be changed once it is set. This can help prevent a number of problems that can occur in other languages when working with mutable variables, such as concurrent access, side effects, and debugging.\nConcurrent access: When multiple threads have access to a mutable variable, it can lead to race conditions where different threads try to access and change the variable at the same time. With immutable variables, this problem is avoided because each thread can only access a specific version of the variable and cannot change it. Side effects: Mutable variables can lead to unintended side effects where a change in one part of the code unexpectedly affects another part of the code. With immutable variables, it is clear that the value of a variable can only be changed in one place, making it easier to reason about the code and prevent unintended side effects. Debugging: When working with mutable variables, it can be difficult to track down the cause of a bug when the value of a variable has changed unexpectedly. With immutable variables, the value of a variable can only be changed in one place, making it easier to trace the flow of data through the code and find the source of a bug. Shadowing Once a variable is created, its value cannot be modified. However, you can create a new variable with the same name and a new value.\nFor example, the following code creates a new variable called \u0026ldquo;x\u0026rdquo;:\nlet x = 5 And eventually we could have another definition as:\nlet x = 10 The first let x = 5 creates the variable and assigns the value of 5 to it. The second let x = 10 creates a new variable also called x and assigns the new value of 10.\nCreating new variables with the same name and new values is referred to as \u0026ldquo;shadowing\u0026rdquo; in F#.\nWhen you create a new variable with the same name as an existing variable, the new variable \u0026ldquo;shadows\u0026rdquo; the existing variable, meaning that it takes precedence and can be used instead of the existing variable. However, the existing variable is still accessible and can be used if needed.\nIt\u0026rsquo;s important to note that shadowing can make the code more difficult to understand and maintain, as it can be unclear which variable is being referred to at a given point in the code. Therefore, it\u0026rsquo;s generally recommended to use meaningful variable names and to avoid shadowing whenever possible.\nDeclaring mutable values However, there may be situations where you need to work with mutable variables, for example when you need to change the value of a field in a record or when you need to update the state of an object.\nTo create a mutable variable in F#, you can use the mutable keyword before the variable\u0026rsquo;s name. For example:\nlet mutable x = 5 x \u0026lt;- 10 // x value change to 10 While there may be situations where you need to work with mutable variables in F#, it\u0026rsquo;s important to be aware of the risks and potential problems that can arise from doing so. In general, it\u0026rsquo;s a good idea to use immutable variables as much as possible and to use mutable variables only when necessary.\n"},{"id":4,"href":"/fsharp-by-example/chapters/functions/","title":"Functions","parent":"Chapters","content":"F# is a functional programming language that allows developers to create powerful and expressive code. One of the key features of F# is its support for functions, which are used to perform specific tasks and return a value. In this chapter, we will explore the basics of functions in F# and how they can be used to create reusable and composable code.\nDefining functions in F# In F#, a function is defined using the keyword let followed by the name of the function, a list of parameters, and the value or expression that the function will return. For example, the following code defines a simple function called \u0026ldquo;add\u0026rdquo; that takes two parameters, x and y, and returns their sum:\nlet add x y = x + y In addition to defining functions in this way, F# also supports curried functions, which are functions that take multiple arguments, but can be called with fewer arguments and return a new function that takes the remaining arguments. For example, the following code defines a curried version of the add function:\nlet add x = fun y -\u0026gt; x + y Using functions in F# Once a function has been defined, it can be called by providing it with the necessary arguments. For example, the following code calls the add function with the arguments 2 and 3 and assigns the result to the variable result:\nlet result = add 2 3 In addition to calling functions directly, F# also supports higher-order functions, which are functions that take other functions as arguments or return them as results. For example, the following code defines a function called \u0026ldquo;map\u0026rdquo; that takes a list and a function and applies the function to each element of the list:\nlet map list f = List.map f list Multiple argument functions In F#, functions can take multiple inputs. These inputs are separated by a space and are passed in as a tuple. For example, the following function takes in two inputs, an int and a string, and returns a concatenation of the two:\nlet concatFunction (x:int) (y:string) = x.ToString() + y We can call this function by passing in two arguments, like so:\nlet result = concatFunction 5 \u0026#34;hello\u0026#34; // result is \u0026#34;5hello\u0026#34; "},{"id":5,"href":"/fsharp-by-example/chapters/lambda-functions/","title":"Lambda Functions","parent":"Chapters","content":"In F#, lambda functions - or if you prefer, anonymous functions - are defined using the fun keyword. These functions are useful for creating small, one-time-use functions that don\u0026rsquo;t need to be named. They can be passed as arguments to other functions, and can be used to create higher-order functions.\nHow to create lambda functions A lambda function is a special type of anonymous function that can be used to create higher-order functions. Lambda functions are defined using the \u0026ldquo;fun\u0026rdquo; keyword, followed by input parameters and the \u0026ldquo;-\u0026gt;\u0026rdquo; operator, which separates the inputs from the function body.\nHere\u0026rsquo;s an example of a lambda function that takes two integers as input and returns their product:\nlet multiplyTwoNumbers = (fun x y -\u0026gt; x * y) This function can be used like any other function, for example:\nlet result = multiplyTwoNumbers 2 3 Currying Currying is a technique in functional programming where a function is transformed into a sequence of functions, each taking a single argument. In F#, currying is done automatically when a function takes multiple arguments.\nHere\u0026rsquo;s an example of currying in F#:\nlet addTwoNumbers x y = x + y let addTwoNumbersCurried = addTwoNumbers let result = addTwoNumbersCurried 2 3 In this example, the addTwoNumbers function is transformed into a curried function addTwoNumbersCurried.\nPartial functions Partial functions are functions that are applied to only a subset of their input arguments. In F#, partial functions are created using the \u0026ldquo;partial\u0026rdquo; keyword.\nHere\u0026rsquo;s an example of a partial function that takes two integers as input and returns their sum:\nlet addTwoNumbers x y = x + y let addTwoNumbersCurried = addTwoNumbers let result = addTwoNumbersCurried 2 3 In this example, the addTwoNumbersPartial function is a partial function that is applied to only one of its input arguments, in this case the argument 2, this function can be used like any other function, for example:\nlet result = addTwoNumbersPartial 3 "},{"id":6,"href":"/fsharp-by-example/chapters/recursion/","title":"Recursion","parent":"Chapters","content":"Recursion is a programming technique in which a function calls itself to solve a problem. It is a powerful tool that allows for elegant and efficient solutions to many types of problems. In this chapter, we will explore recursion in F# and how it can be used to solve problems.\nIntroduction to recursion in F# For example, the factorial function below that calculates the factorial of a given number is recursive. We can first observe this by the keyword rec which indicates to the F# compiler that this function is recursive and that optimizations are necessary for this case. Additionally, we can see in the third line that the function calls itself.\nIn this example, the function \u0026ldquo;factorial\u0026rdquo; is defined as a recursive function using the keyword rec:\nlet rec factorial n = if n = 0 then 1 else n * factorial (n - 1) When thinking about how to program a recursive function, we typically first consider the base case or exit condition. In factorial function it takes a single argument n and uses an if/else statement to determine if the base case of the recursion has been reached.\nIf n value is 0, the function returns 1. If n is not 0, the function calls itself with the argument n - 1 and multiplies the result by n.\nAnother example of recursion in F# is the implementation of a Fibonacci sequence generator:\nlet rec fib n = if n \u0026lt;= 2 then 1 else fib(n-1) + fib(n-2) The function takes a single argument n and uses an if/else statement to determine if the base case of the recursion has been reached. If n is less than or equal to 2, the function returns 1. If n is greater than 2, the function calls itself twice with the arguments n - 1 and n - 2 and adds the results together.\nCall and Evaluation When a recursive function is called, it begins by evaluating the base case. If the base case is true, the function returns a value. If the base case is false, the function calls itself with a modified argument and the process repeats.\nFor example, consider the factorial function. When the function is called with an argument of 5, the first thing that happens is the if statement is evaluated. Since 5 is not equal to 0, the else branch is taken, and the function calls itself with an argument of 4. The function then calls itself with an argument of 3, 2, and 1, until the base case of 0 is reached and the function returns 1. At this point, the previously called instances of the function return their results, which are multiplied together and returned as the final answer.\nIn the case of fibonacci sequence generator, when called with an argument of 6, the function will call itself with argument of 5 and 4. Then it will call itself with argument of 4 and 3 and so on until it reach the base case of 2 and 1, then it will return 1.\n"},{"id":7,"href":"/fsharp-by-example/chapters/tail-call-optimization/","title":"Tail Call Optimization","parent":"Chapters","content":" Efficiency of Recursion in F# One of the key benefits of using recursion in F# is its optimized handling of recursive functions. Unlike languages such as C#, F# is designed with recursion in mind and includes specific optimizations to make recursive functions more efficient.\nOne of the main optimizations implemented in F# is tail call optimization. This optimization allows the compiler to reuse the current stack frame, rather than creating a new one for each recursive call, significantly reducing the amount of memory used and preventing stack overflow errors. This means that the performance of recursive functions in F# is much better than in languages that don\u0026rsquo;t have this optimization.\nAnother optimization that F# has is the pattern matching feature, which allows for more precise and efficient handling of recursive cases. This feature allows the compiler to match the input of a function to a specific pattern and then execute the corresponding code. This reduces the need for explicit conditional statements and makes the code more readable.\nFurthermore, F# has a built-in support for the functional programming paradigm which is a natural fit for recursion. The functional programming approach encourages the use of immutable variables and pure functions, making it easier to reason about the behavior of recursive functions, and leading to fewer bugs and more maintainable code.\nThe combination of tail call optimization, pattern matching, and functional programming support make F# an excellent choice for implementing recursive functions, especially when compared to languages like C# that lack these optimizations.\n"},{"id":8,"href":"/fsharp-by-example/chapters/composition/","title":"Composition","parent":"Chapters","content":"Function composition is the process of combining two or more functions to create a new function.\nComposition operator In F#, we can use the \u0026gt;\u0026gt; operator to compose functions. The \u0026gt;\u0026gt; operator takes the output of the left-hand function and uses it as the input for the right-hand function.\nFor example, let\u0026rsquo;s say we have two functions, f and g, that take an integer as input and return an integer as output. We can create a new function, h, that is the composition of f and g by using the \u0026gt;\u0026gt; operator:\nlet h = f \u0026gt;\u0026gt; g h will take an integer as input and return the output of f when given the output of g as input. This can be written as:\nlet h x = g(f x) A simple example of function composition in F# is composing the delta function to a quadratic function:\nlet quadratic a b c x = a * x * x + b * x + c let delta x = x * x let composed = quadratic 2 3 4 \u0026gt;\u0026gt; delta printfn \u0026#34;Result: %i\u0026#34; (composed 4) In this example, the delta function is being composed with the quadratic function using the \u0026gt;\u0026gt; operator, which is the forward function composition operator. The quadratic function is being called with the arguments 2, 3, and 4, and then the result of that function is being passed as the input to the delta function. The final result is being stored in the composed composed function and called with value 4 to be printed to the console.\nBackward composition This operator (\u0026laquo;) is used to compose functions from right to left. It takes the output of the function on the right side and uses it as the input for the function on the left side. For example, the following code composes the same two functions as before, but in reverse order:\nlet evens numbers = numbers |\u0026gt; List.filter (not \u0026lt;\u0026lt; fun n -\u0026gt; n % 2 = 0) evens [2; 3; 5; 6; 9; 12] // Result is [3; 5; 9] Function composition is a fundamental concept in functional programming, and it is a key feature of F#. By using function composition, you can create complex logic using simple, reusable functions. This makes your code more maintainable and easier to understand.\n"},{"id":9,"href":"/fsharp-by-example/chapters/pipe/","title":"Pipeline operator","parent":"Chapters","content":"F# also has pipeline operators, or pipe operators, which allow us to chain function calls together in a readable way. The pipeline operator |\u0026gt; takes the output of the expression on the left-hand side and uses it as the input for the function on the right-hand side.\nFor example, let\u0026rsquo;s say we have a function f that takes an integer as input and returns an integer as output. We can call this function and pass in the result of another expression using the pipeline operator:\n2 |\u0026gt; f This is equivalent to:\nf 2 We can also chain multiple function calls together using the pipeline operator:\n2 |\u0026gt; f |\u0026gt; g |\u0026gt; h This will take the integer 2, pass it through the function f, take the output and pass it through the function g, then take the output of that and pass it through the function h.\nBackward pipeline This operator is used to compose functions from right to left. It takes the output of the function on the right side and uses it as the input for the function on the left side. For example, the following code composes the same two functions as before, but in reverse order:\nsin \u0026lt;| 2. + 1. // result is 0.1411200081 Pipeline with multiple arguments For to be possible pipe the output from a funtion or values to another function is necessary it have only one argument or it will give us an error:\n3 7 |\u0026gt; min // Error For this function we have to use the double pipe operator:\n(3,7) ||\u0026gt; min // result is 3 If the function has three operators you have to use the triple pipe operator:\n(6,5,2) |||\u0026gt; (fun x y z -\u0026gt; x + y * z) // result is 16 If your function needs four or more arguments its a better idea compose it in smaller parts to them work togheter than use piping.\n"},{"id":10,"href":"/fsharp-by-example/chapters/namespaces/","title":"Namespaces","parent":"Chapters","content":"In F#, a namespace is a container for types, values, and modules. It is used to organize and group related items together, and to prevent naming collisions between items with the same name.\nF# uses a hierarchical naming system, where namespaces are separated by dots. For example, the System namespace contains the Console module, which in turn contains the WriteLine function. To access the WriteLine function, we would use the fully-qualified name System.Console.WriteLine.\n// Example call to System.Console.WriteLine let printString (input: string) (case: string) = match case with | \u0026#34;upper\u0026#34; -\u0026gt; System.Console.WriteLine(input.ToUpper()) | \u0026#34;lower\u0026#34; -\u0026gt; System.Console.WriteLine(input.ToLower()) | _ -\u0026gt; System.Console.WriteLine(input) printString \u0026#34;F# by example\u0026#34; \u0026#34;upper\u0026#34; // Gives \u0026#34;F# BY EXAMPLE\u0026#34; Creating a Namespace The declaration of a namespace consists of the keyword namespace followed by the identifier of the namespace. Everything that is below the namespace declaration will be part of it until a new namespace declaration is reached or the end of the file is reached.\nFor example:\nnamespace MyNamespace let myValue = 42 let myFunction x = x + 1 In the example above, we have created a namespace called MyNamespace that contains a value and a function.\nIt is important to note that namespaces provide a way to organize code and avoid naming collisions. Additionally, they also help to keep the code more readable and maintainable. Therefore, it is considered good practice to use namespaces in your code to keep it organized and easy to understand.\n"},{"id":11,"href":"/fsharp-by-example/chapters/nested-namespaces/","title":"Nested Namespaces","parent":"Chapters","content":"In F#, it is possible to organize code within namespaces in a hierarchical manner by using nested namespaces. A nested namespace is a namespace that is defined within another namespace.\nTo declare a nested namespace, the keyword namespace is used followed by the identifier of the parent namespace, and then the nested namespace is defined using the namespace keyword again followed by the identifier of the nested namespace.\nFor example:\nnamespace ParentNamespace namespace ChildNamespace //Code here belongs to ChildNamespace namespace AnotherChildNamespace //Code here belongs to AnotherChildNamespace It\u0026rsquo;s important to note that nested namespaces inherit the parent namespace identifier, therefore the full name of the nested namespace will be ParentNamespace.ChildNamespace.\nUsing nested namespaces can be beneficial when trying to organize large code bases and to avoid naming conflicts. It allows you to create a more structured and organized namespace hierarchy that reflects the organization of the code itself. This makes it easier to understand the codebase, and it also makes it easier to find and use the specific code that is needed.\nAdditionally, nested namespaces also help to control the visibility of types, since types defined in a nested namespace are only visible within the parent namespace and its nested namespaces, unless they are explicitly made visible by using the open keyword.\nIt\u0026rsquo;s worth mentioning that you can use any number of nested namespaces, but it is important to use them judiciously to avoid over-complicating the codebase and make it harder to understand and maintain.\nOne example of using nested modules in F# is creating a module for a specific functionality within a larger module that represents a larger project or library. For example, let\u0026rsquo;s say we have a project called \u0026ldquo;FinancialApp\u0026rdquo; and within that project, we have a module called \u0026ldquo;Calculations\u0026rdquo;. Within the \u0026ldquo;Calculations\u0026rdquo; module, we can create a nested module called \u0026ldquo;Investments\u0026rdquo; that contains functions specific to investment calculations.\nmodule FinancialApp module Calculations module Investments let calculateROI (investment:float) (returns:float) = (returns - investment) / investment let calculateLoanPayment (principal:float) (rate:float) (term:int) = let r = rate / 12.0 let t = float term (principal * r) / (1.0 - (1.0 + r) ** (-t)) We can call the functions in the nested module as follow:\nlet myInvestment = 1000.0 let myReturns = 1100.0 let roi = FinancialApp.Calculations.Investments.calculateROI myInvestment myReturns Nesting modules in this way can help keep our code organized and make it easier to find and use specific functionality within a larger project.\n"},{"id":12,"href":"/fsharp-by-example/chapters/modules/","title":"Modules","parent":"Chapters","content":"Modules are a way to organize and group related functions and values in F#. They are similar to namespaces in other languages, but with some key differences.\nWhat is a module? A module in F# is a unit of code that can contain type declarations, function definitions, and value definitions. It provides a way to organize and structure your code into logical units, making it easier to maintain and reuse your code. Modules can also help to encapsulate and hide implementation details, making it easier to change the implementation without affecting the rest of the code.\nUsing modules To create a module in F#, use the keyword \u0026ldquo;module\u0026rdquo; followed by the name of the module. For example:\nmodule MyModule You can then define your types, functions, and values within the module. For example, consider the following code snippet:\nmodule MathFunctions let add x y = x + y let subtract x y = x - y In this example, we have created a module named “MathFunctions” that contains two functions, “add” and “subtract”. You can then access these functions from other parts of your code by using the module name followed by the function name.\nlet result = MathFunctions.add 2 3 "},{"id":13,"href":"/fsharp-by-example/chapters/organization/","title":"Organization","parent":"Chapters","content":"Code organization is a crucial aspect of software development and it is essential to choose the right tools to ensure that your code is well-structured, maintainable, and scalable. In F#, modules and namespaces are two of the tools that are commonly used to achieve code organization.\nChoosing between Modules and Namespaces When deciding between using modules or namespaces for code organization, it is important to consider the purpose of each tool and to choose the one that best fits your needs.\nWhen use modules? If you need to group related functions, types, and values into a single unit, then modules are the better choice. Modules provide a way to encapsulate implementation details and to improve code reusability.\nExample:\n// Define a module named \u0026#34;MyModule\u0026#34; module MyModule // Define a functions let add x y = x + y let subtract x y = x - y let multiply x y = x * y let divide x y = x / y // Define a list named \u0026#34;mathOperations\u0026#34; that contains all four functions defined above let mathOperations = [add; subtract; multiply; divide] // Define a function named \u0026#34;processOperations\u0026#34; that takes two arguments \u0026#34;x\u0026#34; and \u0026#34;y\u0026#34; // and returns the result of each of the four functions in the \u0026#34;mathOperations\u0026#34; list for the given inputs let processOperations x y = mathOperations |\u0026gt; List.map (fun operation -\u0026gt; operation x y) Then we can open this module in another file and use as:\n// We can open the module open MyModule // And call the \u0026#34;processOperations\u0026#34; function let results = processOperations 5 3 printfn \u0026#34;The results of all operations are: %A.\u0026#34; results // Output: The results of all operations are: [8; 2; 15; 1.666667]. When use namespaces? If you need to group types together and avoid naming conflicts, then namespaces are the better choice. Namespaces provide a way to organize code into logical units and to make it easier to manage your code as it grows.\n// Define a namespace named \u0026#34;Math\u0026#34; namespace Math // Define a type named \u0026#34;Calculator\u0026#34; within the \u0026#34;Math\u0026#34; namespace type Calculator = static member Add (x: int, y: int) = x + y static member Subtract (x: int, y: int) = x - y static member Multiply (x: int, y: int) = x * y static member Divide (x: int, y: int) = x / y // Define another namespace named \u0026#34;Utils\u0026#34; namespace Utils // Define a type named \u0026#34;Calculator\u0026#34; within the \u0026#34;Utils\u0026#34; namespace type Calculator = static member ConvertToFahrenheit (c: float) = (c * 9.0 / 5.0) + 32.0 static member ConvertToCelsius (f: float) = (f - 32.0) * 5.0 / 9.0 In this example, we have defined two namespaces: Math and Utils. Both namespaces contain a type named Calculator, but there is no naming conflict because each Calculator type is defined within its respective namespace. This makes it easier to manage our code as it grows and to avoid naming conflicts. We can access the Calculator types in each namespace by referencing them with the full namespace name, for example Math.Calculator or Utils.Calculator.\nComparison Table To help you make an informed decision when choosing between modules and namespaces for code organization, we have provided a comparison table that summarizes the key differences between the two tools.\nModules Namespaces Can contain functions, types, and values Can only contain types Encapsulate implementation details Organize code into logical units Improve code reusability Avoid naming conflicts between types Provide a way to organize code into logical units "},{"id":14,"href":"/fsharp-by-example/chapters/types/","title":"Types","parent":"Chapters","content":"F# is a statically typed language, meaning that the type of a value must be known at compile-time. F# has several built-in types that can be used to represent values in your programs. We\u0026rsquo;ll explore the basic types in F# and how to use them.\nNumbers F# supports several numeric types such as integers (int, long, byte), floating-point numbers (float), and decimal numbers (decimal). The following table shows the size and range of values for each type:\nType Size Range byte 8-bit 0 to 255 int 32-bit -2,147,483,648 to 2,147,483,647 float 32-bit Approximately ±1.5 × 10^−45 to ±3.4 × 10^38 long 64-bit -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 decimal 128-bit ±1.0 × 10^−28 to ±7.9 × 10^28 Booleans The boolean type in F# is used to represent true/false values. It is defined as bool. The values true and false are the only two valid values of this type.\nlet value = true Strings Strings are sequences of characters used to represent text. In F#, strings are defined using double quotes \u0026ldquo;. For example:\nlet greeting = \u0026#34;Hello, World!\u0026#34; Char A char type represents a single Unicode character. It is defined using single quotes \u0026lsquo;. For example:\nlet letter = \u0026#39;A\u0026#39; Tuples Tuples are a way to group values together into a single value. Tuples in F# can have any number of elements and each element can be of a different type. For example:\nlet nameAge = (\u0026#34;John\u0026#34;, 30) Arrays An array is a collection of values of the same type. Arrays in F# are defined using square brackets [ ]. For example:\nlet numbers = [1; 2; 3; 4; 5] Lists Lists are a data structure in F# that represent a sequence of values. Lists are similar to arrays, but they are immutable, meaning that once a list is created, its values cannot be changed. Lists in F# are defined using square brackets [ ]. For example:\nlet numbers = [1; 2; 3; 4; 5] BigInteger The BigInteger type in F# is used to represent arbitrarily large integers. Unlike the int and long types, BigInteger does not have a maximum size, so it can be used to represent integers of any size. The BigInteger type is defined in the System.Numerics namespace and can be used by opening the System.Numerics module at the top of your code.\nopen System.Numerics let bigInt = BigInteger(1000000000000000000) "},{"id":15,"href":"/fsharp-by-example/chapters/unit/","title":"Unit","parent":"Chapters","content":"F# is a functional programming language that is commonly used for developing applications in a wide range of domains. One of the core concepts in F# is the concept of a unit type, which is represented by the type unit.\nlet myUnit : unit = () It\u0026rsquo;s important to note that the unit type only has one possible value, which is (), so declaring a variable of type unit is not very useful in practice. However, this code is valid and demonstrates how to declare a variable of type unit.\nThe unit type is a special type in F# that represents the absence of a value. It is used to indicate that a function returns no meaningful value, and is typically used in functional programming when the purpose of a function is to perform some action, such as printing a message to the console, rather than to return a value.\nThe unit type is a singleton type, which means that there is only one instance of it. This instance is represented by the value (), and it is used to indicate that a function has completed its work and has no meaningful return value.\nlet printMessage message = printfn \u0026#34;%s\u0026#34; message () // This will print the message \u0026#34;Hello, World!\u0026#34; to the console and return unit printMessage \u0026#34;Hello, World!\u0026#34; In F#, functions that return unit are often referred to as \u0026ldquo;procedures.\u0026rdquo; Procedures are functions that perform some action and return unit as a result. They are used to implement side effects, such as printing a message to the console, and are typically used in combination with other functions that return meaningful values.\nOne important thing to note about the unit type is that it is not equivalent to void in C# or other programming languages. In C#, void represents the absence of a return value, but in F#, unit is a value type with a single instance, ().\nThe unit type is particularly useful in functional programming, as it allows developers to write code that is free of side effects and is easy to reason about. For example, if a function returns unit, it can be guaranteed that the function has no side effects, and that it only performs the actions that it is intended to perform.\n"},{"id":16,"href":"/fsharp-by-example/chapters/casting/","title":"Casting","parent":"Chapters","content":"Type casting in F# is a process of converting one type of value to another type of value. This can be useful in situations where the type of a value needs to be changed in order to be used in a specific context. There are several ways to perform type casting in F#, including explicit casting, implicit casting, and type coercion.\nExplicit Casting Explicit casting in F# involves explicitly specifying the target type for a value, using the :\u0026gt; operator. For example:\nlet intValue = 42 let stringValue = intValue :\u0026gt; string Implicit Casting Implicit casting in F# occurs when the compiler determines the target type based on context. For example, when you declare a variable numeric that is bigger but set a value that fits in a smaller type:\ntype Shape = | Circle of float | Rectangle of float * float let shapeValue = Circle 3.14 // shapeValue is a value of type Shape, but it is implicitly cast to the float type in the circleValue variable by using pattern matching. let circleValue = match shapeValue with | Circle r -\u0026gt; r | Rectangle _ -\u0026gt; failwith \u0026#34;This is a rectangle, not a circle.\u0026#34; Type Coercion Type coercion is a special form of implicit casting that is used to convert between numeric types in F#. For example, the following code converts an integer value to a float using float operator:\nlet intValue = 42 let floatValue = double intValue List of casting operators The following table shows some of the most useful conversion operators defined in F#: Operator Description byte Convert to byte, an 8-bit unsigned type. sbyte Convert to signed byte. int Convert to a 32-bit signed integer. float, double Convert to a 64-bit double-precision IEEE floating point number. single Convert to a 32-bit single-precision IEEE floating point number. decimal Convert to System.Decimal. char Convert to System.Char, a Unicode character. enum Convert to an enumerated type. "},{"id":17,"href":"/fsharp-by-example/chapters/boolean-operators/","title":"Boolean Operators","parent":"Chapters","content":"Boolean operators are used to perform logical operations on Boolean values (i.e., true and false). F# provides several boolean operators that can be used to test conditions, compare values, and perform other types of operations. In this chapter, we will discuss the different boolean operators in F# and how to use them in your code.\nAND The logical AND operator (\u0026amp;\u0026amp;) is used to combine two conditions. The result of the AND operation is true if both conditions are true, and false if either condition is false. The syntax for the AND operator in F# is as follows:\ncondition1 \u0026amp;\u0026amp; condition2 For example, consider the following code:\nlet x = 5 let y = 6 if x \u0026lt; 10 \u0026amp;\u0026amp; y \u0026gt; 5 then printfn \u0026#34;Both conditions are true\u0026#34; else printfn \u0026#34;Either condition is false\u0026#34; // Output: Both conditions are true OR The logical OR operator (||) is used to combine two conditions. The result of the OR operation is true if either condition is true, and false if both conditions are false. The syntax for the OR operator in F# is as follows:\ncondition1 || condition2 For example, consider the following code:\nlet x = 5 let y = 6 if x \u0026lt; 10 || y \u0026gt; 10 then printfn \u0026#34;Either condition is true\u0026#34; else printfn \u0026#34;Both conditions are false\u0026#34; // Output: Either condition is true NOT The logical NOT operator (not) is used to negate a condition. The result of the NOT operation is true if the condition is false, and false if the condition is true. The syntax for the NOT operator in F# is as follows:\nnot condition For example, consider the following code:\nlet x = 5 if not (x \u0026gt; 10) then printfn \u0026#34;The condition is false\u0026#34; else printfn \u0026#34;The condition is true\u0026#34; // Output: The condition is false "},{"id":18,"href":"/fsharp-by-example/chapters/strings/","title":"Strings","parent":"Chapters","content":"In F#, a string is a sequence of Unicode characters enclosed in double quotes. Strings are often used to store and manipulate text data, such as names, addresses, and messages.\nString Literal A string literal is a string that is directly specified in the source code. String literals can be defined by enclosing the text in double quotes:\nlet name = \u0026#34;John Doe\u0026#34; String Interpolation String interpolation is a feature in F# that allows you to embed expressions within a string literal. The expression is enclosed in curly braces {} and is evaluated at runtime:\nlet name = \u0026#34;Don Syme\u0026#34; let age = 51 printfn $\u0026#34;Name: {name}, Age: {age}\u0026#34; // Output: Name: Don Syme, Age: 51 Interpolated strings can also have F# format specifiers to enforce type safety:\nlet name = \u0026#34;Camilo de Azevedo\u0026#34; let age = 27 printfn $\u0026#34;Name: %s{name}, Age: %d{age}\u0026#34; // Output: Name: Camilo de Azevedo, Age: 27 printfn $\u0026#34;Name: %s{age}, Age: %d{name}\u0026#34; // Output: Error, type mismatch "},{"id":19,"href":"/fsharp-by-example/chapters/string-manipulation/","title":"String Manipulation","parent":"Chapters","content":"F# provides several functions and methods for string manipulation.\nSplit The split function splits a string into an array of substrings based on a specified separator:\nlet sentence = \u0026#34;OCaml, Standard ML, F#\u0026#34; let names = sentence.Split \u0026#34;,\u0026#34; // val names: string array = [|\u0026#34;OCaml\u0026#34;; \u0026#34; Standard ML\u0026#34;; \u0026#34; F#\u0026#34;|] Replace The replace function replaces all occurrences of a specified string with another string:\nlet sentence = \u0026#34;OCaml, Standard ML, F#\u0026#34; let updatedSentence = sentence.Replace(\u0026#34;Standard ML\u0026#34;,\u0026#34;Haskell\u0026#34;) // val updatedSentence: string = \u0026#34;OCaml, Haskell, F#\u0026#34; Substring The substring function returns a substring from a specified starting index to an optional ending index:\nlet sentence = \u0026#34;OCaml, Standard ML, F#\u0026#34; let subSentence = sentence.Substring(0, 5) // val subSentence: string = \u0026#34;OCaml\u0026#34; Trim The trim function removes all leading and trailing white space characters from a string:\nlet sentence = \u0026#34; F# is awesome. \u0026#34; let trimmedSentence = sentence.Trim() // val trimmedSentence: string = \u0026#34;F# is awesome.\u0026#34; Obs: The F# standard library provides a module System.String that contains a variety of functions for working with strings.\nConcat The String.concat function is used to join a sequence of strings into a single string with a delimeter:\nlet strings = [ \u0026#34;OCaml\u0026#34;; \u0026#34;Standard ML\u0026#34;; \u0026#34;F#\u0026#34; ] let fullString = String.concat \u0026#34;, \u0026#34; strings // val fullString: string = \u0026#34;OCaml, Standard ML, F#\u0026#34; Length The String.length function is used to returns the value of length of the string:\nlet content = \u0026#34;F# for fun and profit\u0026#34; let strSize = String.length content // val strSize: int = 21 "},{"id":20,"href":"/fsharp-by-example/chapters/list/","title":"Lists","parent":"Chapters","content":"Lists are a commonly used data structure in F# and they provide a way to store sequences of values. In F#, lists are immutable, meaning that their contents cannot be changed after they are created. This feature makes them well-suited for functional programming.\nCreating Lists In F#, lists can be created in several ways. The simplest way to create a list is to use square brackets and separate the elements with semicolons. For example:\nlet numbers = [1; 2; 3] Another way to create lists is to use the init function, which creates a list with a specified number of elements. The following code creates a list with 5 elements:\nlet fiveElements = List.init 5 (fun i -\u0026gt; i + 1) We\u0026rsquo;ll see more about functions in List module next.\nAccessing Elements in Lists In F#, elements in a list can be accessed using indexing. The first element in a list has an index of 0, and so on. For example:\nlet numbers = [1; 2; 3] let first = numbers.[0] // first will be 1 In addition to indexing, other functions can be used to access elements in a list. The head function returns the first element in a list, while the tail function returns the rest of the list. The following code demonstrates how to use these functions:\nlet numbers = [1; 2; 3] let first = List.head numbers // first will be 1 let tail = List.tail numbers // tail will be [2; 3] Adding Values to Lists In F#, we can add elements to a list using the :: operator. This operator adds a new element to the head of the list, creating a new list. For example, we can add the element 4 to the list [1; 2; 3] as follows:\nlet myList = 4 :: [1; 2; 3] The resulting list will be [4; 1; 2; 3].\nWe can also concatenate two lists using the @ operator. For example, to concatenate the lists [1; 2] and [3; 4], we can use the following code:\nlet list1 = [1; 2] let list2 = [3; 4] let concatenatedList = list1 @ list2 The resulting list will be [1; 2; 3; 4].\nIt\u0026rsquo;s worth noting that adding an element to the head of a list can be an expensive operation, especially for large lists, since all the elements of the list have to be shifted by one position. Therefore, it\u0026rsquo;s usually more efficient to build a list by adding elements to the tail and then reversing the list at the end, if necessary.\n"},{"id":21,"href":"/fsharp-by-example/chapters/list-module/","title":"List Module","parent":"Chapters","content":"In addition to the basic list operations that we covered in the previous chapter, F# also provides a List module with many useful functions for working with lists. This module provides a variety of functions for manipulating lists and performing common operations.\nCommon Functions There are many other functions in the List module that are beyond the scope of this chapter, but some notable ones include:\nappend Concatenates two lists together\nlet list1 = [1; 2; 3] let list2 = [4; 5; 6] let concatenated = List.append list1 list2 // concatenated will be [1; 2; 3; 4; 5; 6] length Returns the length of a list\nlet myList = [1; 2; 3; 4; 5] let length = List.length myList // length will be 5 exists Returns true if at least one element in a list satisfies a given predicate\nlet myList = [1; 3; 5; 7; 8; 9] let hasEven = List.exists (fun x -\u0026gt; x % 2 = 0) myList // hasEven will be true forAll Returns true if all elements in a list satisfy a given predicate\nlet myList = [2; 4; 6; 8] let allEven = List.forAll (fun x -\u0026gt; x % 2 = 0) myList // allEven will be true let myList2 = [2; 4; 6; 7; 8] let allEven2 = List.forAll (fun x -\u0026gt; x % 2 = 0) myList2 // allEven2 will be false sortBy Sorts a list by a given comparison function\nlet myList = [\u0026#34;apple\u0026#34;; \u0026#34;banana\u0026#34;; \u0026#34;cherry\u0026#34;; \u0026#34;date\u0026#34;; \u0026#34;elderberry\u0026#34;] let sortedList = List.sortBy (fun x -\u0026gt; x.Length) myList // sortedList will be [\u0026#34;date\u0026#34;; \u0026#34;apple\u0026#34;; \u0026#34;cherry\u0026#34;; \u0026#34;banana\u0026#34;; \u0026#34;elderberry\u0026#34;] take Returns the first n elements of a list\nlet myList = [1; 2; 3; 4; 5; 6; 7] let firstThree = List.take 3 myList // firstThree will be [1; 2; 3] skip Skips the first n elements of a list\nlet myList = [1; 2; 3; 4; 5; 6; 7] let afterThree = List.skip 3 myList // afterThree will be [4; 5; 6; 7] "},{"id":22,"href":"/fsharp-by-example/chapters/range-operator/","title":"Range Operator","parent":"Chapters","content":"The range operator .. is used to declare lists of ordered sequence values.\nBasic Usage Using the range operator, we can quickly create a list of ordered sequence values with a single line of code. For instance, the following F# code creates a list of integers ranging from 1 to 5:\n[1..5] // Output: [1; 2; 3; 4; 5] Similarly, we can create a list of characters ranging from \u0026lsquo;a\u0026rsquo; to \u0026lsquo;f\u0026rsquo;:\n[\u0026#39;a\u0026#39;..\u0026#39;f\u0026#39;] // Output: [\u0026#39;a\u0026#39;; \u0026#39;b\u0026#39;; \u0026#39;c\u0026#39;; \u0026#39;d\u0026#39;; \u0026#39;e\u0026#39;; \u0026#39;f\u0026#39;] Specifying a Step Value By default, the range operator creates a list with an increment of 1. However, we can change the increment by specifying a step value. For instance, to create a list of integers ranging from 1 to 10 with an increment of 2, we can use the following code:\n[1..2..10] // Output: [1; 3; 5; 7; 9] Here, the 2 in 1..2..10 specifies that we want the range to increment by 2 instead of the default of 1.\nReversing a Range The range operator can also be used to create a list in reverse order. To create a list of integers ranging from 10 to 0 in reverse order, we can use the following code:\n[10..-1..0];; // Output: [10; 9; 8; 7; 6; 5; 4; 3; 2; 1; 0] Here, the -1 in 10..-1..0 specifies that we want the range to increment by -1, which effectively creates a reversed list.\n"},{"id":23,"href":"/fsharp-by-example/chapters/list-comprehensisions/","title":"List Comprehensisions","parent":"Chapters","content":"List Comprehensions is a more powerful way of constructing lists in F# that is derived from the mathematical concept of \u0026ldquo;set comprehensions\u0026rdquo; or \u0026ldquo;Set-builder notation\u0026rdquo;. A set comprehension is a list defined from a set of rules that define the properties that its elements must satisfy.\nAny comprehension has at least three parts:\nCollection: the source of the values that will be in the list, in F# usually a range or a list. Identifier or Pattern: the identifier used to represent each element in the list or a pattern to match elements of a complex type. Output Function: the expression that maps the values of the collection to the items in the list. Here is an example of a list comprehension in F# that generates a list of even numbers:\n[for x in 1..10 do yield 2 * x];; The above code uses a range of integers 1..10 as the source collection, uses the identifier x to represent each element of the collection, and applies the output function 2 * x to each element to produce a new list of even numbers.\nList comprehensions can also be chained together:\n[for r in 1..8 do for c in 1..8 do if r \u0026lt;\u0026gt; c then yield (r,c)] The above code generates a list of all pairs of numbers from 1 to 8, except pairs where the numbers are equal.\nList Comprehensions are a concise and expressive way to construct lists and can be used in many different scenarios in F#.\n"},{"id":24,"href":"/fsharp-by-example/chapters/arrays/","title":"Arrays","parent":"Chapters","content":"Arrays in F# are similar to lists but have different performance characteristics and the ability to index any value directly in the array. In this chapter, we will cover the syntax of arrays and how they differ from lists.\nCreating Arrays To create an array, we use the same syntax as for lists, but with pipes instead of square brackets:\n[|1; 2; 3|] // Output: [|1; 2; 3|] The result of the code above is an array containing the values 1, 2, and 3.\nAccessing Items in an Array To access an item in an array, we use the syntax of square brackets and the position of the item we want to access:\n[|1; 2; 3|].[1] // Output: 2 The code above will return the second item in the array, which is 2.\nAdding Elements to Arrays Unlike lists, arrays don\u0026rsquo;t have a head operator (::) to add elements. However, we can use array slicing to add elements to an array.\nlet arr = [| 1; 2; 3 |] // Adding an element to the end of the array let newArr = Array.append arr [| 4 |] // Output: [|1; 2; 3; 4|] // Adding an element to the beginning of the array let newArr2 = Array.append [| 0 |] arr // Output: [|0; 1; 2; 3|] // Adding elements at a specific index let idx = 1 let newArr3 = Array.concat [ arr.[0..idx-1]; [| 10; 20 |]; arr.[idx..] ] // Output: [|1; 10; 20; 2; 3|] List Comprehensions in Arrays Arrays support list comprehensions in the same way as lists. We can use the for\u0026hellip;do or for\u0026hellip;yield keywords to generate an array. Here\u0026rsquo;s an example:\n[| for x in [1..3] do yield 2 * x |] // Output: [|2; 4; 6|] In this example, we create an array of doubled values from the range 1 to 3.\n"},{"id":25,"href":"/fsharp-by-example/chapters/maps/","title":"Maps","parent":"Chapters","content":"The map function is a common function used in many functional programming languages, including F#. It is used to transform the elements of a collection using a given function, producing a new collection with the same length but with each element transformed by the given function.\nSyntax The syntax of the map function in F# is as follows:\nList.map (function) list Array.map (function) array Here, List.map and Array.map are the two versions of the function, and function is the function used to transform the elements of the collection. The list or array is the collection to be transformed.\nExample Let\u0026rsquo;s say we have a list of numbers and we want to transform each element of the list by doubling it. We can use the map function as follows:\nlet numbers = [1; 2; 3; 4; 5] let doubledNumbers = List.map (fun x -\u0026gt; x * 2) numbers Here, we define a list of numbers and then use the List.map function to apply the lambda function fun x -\u0026gt; x * 2 to each element of the list. This creates a new list, doubledNumbers, with each element transformed by the given function.\nUsing Map with Arrays Similarly, we can use the Array.map function to transform the elements of an array. For example:\nlet numbers = [|1; 2; 3; 4; 5|] let doubledNumbers = Array.map (fun x -\u0026gt; x * 2) numbers In this case, we define an array of numbers and then use the Array.map function to apply the lambda function fun x -\u0026gt; x * 2 to each element of the array. This creates a new array, doubledNumbers, with each element transformed by the given function.\nThe map function is a useful tool for transforming collections in F#. By using the map function, we can easily apply a given function to each element of a collection and create a new collection with the transformed elements. Whether we are working with lists or arrays, the map function can help us write concise and efficient code.\n"},{"id":26,"href":"/fsharp-by-example/chapters/filter/","title":"Filter","parent":"Chapters","content":"In F#, the filter function allows you to remove elements from a sequence that do not match a specified condition. The resulting sequence only contains elements that satisfy the condition.\nSyntax The syntax for filter is as follows:\nfilter (predicate: \u0026#39;a -\u0026gt; bool) (list: \u0026#39;a list) : \u0026#39;a list where:\npredicate is a function that takes an element of type generic - we\u0026rsquo;ll see that - and returns a boolean value. list is a list of elements of type of passed generic type. The return value is a new list of elements of the type generic that pass the predicate test. Example Suppose we have a list of integers:\nlet numbers = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] We can use filter to remove all even numbers from the list:\nlet odds = filter (fun x -\u0026gt; x % 2 \u0026lt;\u0026gt; 0) numbers In this example, fun x -\u0026gt; x % 2 \u0026lt;\u0026gt; 0 is the predicate function that checks if a given element is odd. The resulting list odds contains only the odd numbers in the original list:\n[1; 3; 5; 7; 9] Using Filter with Arrays The filter function can also be used with arrays. Here\u0026rsquo;s an example:\nlet numbers = [|1; 2; 3; 4; 5; 6; 7; 8; 9; 10|] let odds = filter (fun x -\u0026gt; x % 2 \u0026lt;\u0026gt; 0) numbers The resulting array odds contains only the odd numbers in the original array:\n[|1; 3; 5; 7; 9|] The filter function is a powerful tool in F# that allows you to remove elements from a sequence that do not match a specified condition. It can be used with both lists and arrays, and is a great tool for data manipulation and processing.\n"},{"id":27,"href":"/fsharp-by-example/chapters/tuples/","title":"Tuples","parent":"Chapters","content":"Tuples are ordered groups of anonymous values that are commonly used to store intermediate calculation results or to return multiple values from a function. The values in a tuple can be of different types and their types are written in order and separated by an asterisk. All tuples are immutable by default.\nIn F#, tuples are created using parentheses, and the values inside the parentheses are separated by commas. For example:\n(1, \u0026#34;Camilo\u0026#34;, 1.80, true) // =\u0026gt; val it : int * string * float * bool = (1, \u0026#34;Camilo\u0026#34;, 1.8, true) his creates a tuple with four values of different types: an integer, a string, a float, and a boolean.\nSince tuples have no named values, their elements are accessed by position. For tuples with only two elements, the fst and snd functions can be used to access the first and second elements, respectively. For example:\nfst (\u0026#34;Galileu\u0026#34;, 6) // =\u0026gt; val it : string = \u0026#34;Galileu\u0026#34; snd (\u0026#34;Galileu\u0026#34;, 6) // =\u0026gt; val it : int = 6 Tuples can also be nested, allowing for the creation of more complex data structures. For example:\nlet myNestedTuple = (\u0026#34;F#\u0026#34;, (1, 2), [3; 4; 5]) This creates a tuple with three elements, where the second element is another tuple and the third element is a list. Elements of nested tuples can be accessed using nested pattern matching or by using functions like fst and snd multiple times.\nIn addition to being used for returning multiple values from a function, tuples are also useful for passing multiple arguments to a function. For example, instead of passing three arguments to a function, you can pass a tuple with three elements. This can make the code more concise and easier to read.\n"},{"id":28,"href":"/fsharp-by-example/chapters/records/","title":"Records","parent":"Chapters","content":"Records are similar to tuples in that they are used to group related values together. However, unlike tuples, records allow you to name the fields, which can make the code more readable and maintainable. In F#, records are defined using the type keyword, followed by the record name and the field names and types inside curly braces.\nHere\u0026rsquo;s an example of a record definition for a person:\ntype Person = { Name : string Age : int } You can create an instance of a record by specifying the field names and values, separated by commas and enclosed in curly braces:\nlet person = { Name = \u0026#34;Eduardo Rafael\u0026#34;; Age = 24 } To access the fields of a record, you can use dot notation followed by the field name:\nperson.Name // =\u0026gt; \u0026#34;Eduardo Rafael\u0026#34; person.Age // =\u0026gt; 24 Records can also have optional fields and mutable fields. Optional fields are indicated by a question mark after the field name, and mutable fields are indicated by the mutable keyword before the field name:\ntype Person = { Name : string Age : int mutable TwitchLink : string option } let mutablePerson = { Name = \u0026#34;Eduardo Rafael\u0026#34;; Age = 24; TwitchLink = Some \u0026#34;https://www.twitch.tv/eduardorfs\u0026#34; } mutablePerson.Address \u0026lt;- None Records can also be used as function parameters and return types, which can make it easy to work with structured data:\nlet getFullName { Name = first; LastName = last } = sprintf \u0026#34;%s %s\u0026#34; first last let person = { Name = \u0026#34;Eduardo Rafael\u0026#34;; LastName = \u0026#34;da Silva\u0026#34; } let fullName = getFullName person // Output: \u0026#34;Eduardo Rafael da Silva\u0026#34; Records are a powerful tool for organizing related data in F#. They allow you to name fields, which can improve code readability, and they can be used as function parameters and return types.\n"},{"id":29,"href":"/fsharp-by-example/chapters/members/","title":"Members","parent":"Chapters","content":"Records in F# are not just simple data structures, but they can also contain functions as members. These functions are called record members and can be used to encapsulate behavior that operates on the data stored in the record.\nTo define a record member, we can use the member keyword followed by the member name and the member definition. Here\u0026rsquo;s an example of a record with a member function that returns a greeting message:\ntype Person = { name: string; age: int; member this.greet() = sprintf \u0026#34;Hello, my name is %s and I am %d years old.\u0026#34; this.name this.age } let person = { name = \u0026#34;John\u0026#34;; age = 30 } person.greet() // Output: \u0026#34;Hello, my name is John and I am 30 years old.\u0026#34; Record members can access the fields of the record they belong to using the this keyword, which refers to the current instance of the record. This allows us to define behavior that is closely tied to the data stored in the record.\nRecord members can also be defined as properties, which are similar to fields but with associated behavior. To define a property, we can use the member keyword followed by the property name and the property definition. Here\u0026rsquo;s an example of a record with a property that computes the full name of the person:\ntype Person = { first: string; last: string; member this.FullName with get() = sprintf \u0026#34;%s %s\u0026#34; this.first this.last } let person = { first = \u0026#34;John\u0026#34;; last = \u0026#34;Doe\u0026#34; } person.FullName // Output: \u0026#34;John Doe\u0026#34; In this example, we defined a property called FullName that returns the concatenation of the first and last fields of the record. The with get() syntax specifies that this is a read-only property, meaning that it can only be accessed and not modified.\nRecord members can also be defined as methods, which are similar to functions but with associated behavior. To define a method, we can use the member keyword followed by the method name and the method definition. Here\u0026rsquo;s an example of a record with a method that computes the age of the person in dog years:\ntype Person = { name: string; age: int; member this.AgeInDogYears() = this.age * 7 } let person = { name = \u0026#34;John\u0026#34;; age = 30 } person.AgeInDogYears() // Output: 210 In this example, we defined a method called AgeInDogYears that multiplies the age field of the record by 7 to compute the age of the person in dog years.\nRecord members can also be defined as constructors, which are special functions that create new instances of the record. To define a constructor, we can use the new keyword followed by the constructor definition. Here\u0026rsquo;s an example of a record with a constructor that validates the input values:\ntype Person = { name: string; age: int; member this.NameAndAge(n: string, a: int) = if a \u0026lt; 0 then invalidArg \u0026#34;age\u0026#34; \u0026#34;Age must be positive.\u0026#34; { name = n; age = a } } let person = Person.NameAndAge(\u0026#34;John\u0026#34;, 30) In this example, we defined a constructor called NameAndAge that takes two arguments: n for the name and a for the age. The constructor validates that the age is positive and creates a new instance of the record.\n"},{"id":30,"href":"/fsharp-by-example/chapters/discriminated-union/","title":"Discriminated Union","parent":"Chapters","content":" Discriminated Union in F# In F#, programmers are used to defining types to structure data, but what if types could define a set of choices? A Discriminated Union is a type that can have a certain set of cases, and the value of a Discriminated Union must be one of those cases that were defined. Because the representation of a Discriminated Union is the sum of all its cases, it is also known as a Sum Type, corresponding to types such as products in tuples. Discriminated Union can have methods and properties.\nDefining a Discriminated Union A Discriminated Union is defined using the type keyword, followed by the name of the Discriminated Union, and then a vertical bar (|) separated list of cases.\nLet\u0026rsquo;s take a look at an example of a discriminated union that represents French playing cards:\ntype Suit = Spades | Hearts | Diamonds | Clubs Note that the cases have to be defined using PascalCase.\nWe defined a discriminated union called Suit with four cases: Spades, Hearts, Diamonds, and Clubs. We can think of a Discriminated Union as enumerations. A value that is a value of type Suit must be one of the possible options defined in its enumeration.\nAdding Data to Cases Discriminated Union can also have additional data associated with each case. The type of this data can be anything from primitives to tuples, records, and even other Discriminated Unions. Let\u0026rsquo;s take the previous example of defining cards and create our ranks adding additional data to each rank representing the point value:\ntype Rank = | Ace of int | King of int | Queen of int | Jack of int | Ten of int | Nine of int | Eight of int | Seven of int | Six of int In this example, each case of the Discriminated Union Rank has an additional int value associated with it, representing the point value for each rank. We can initialize a value of Rank by providing the int value associated with the specific rank. For example:\nlet ace = Ace(14) let six = Six(6) Combining Discriminated Unions Discriminated Unions can also be combined to create more complex data types. For example, let\u0026rsquo;s consider two Discriminated Unions, one defining the card ranks and another defining the card suits, we can now define a Union Type with two cases, where the first case indicates that the card is a joker, and the second case defines that it is a regular card, which is a value consisting of a Rank and a Suit:\ntype Card = | Joker | Regular of Rank * Suit In this example, Joker is the first case of the Discriminated Union Card and it has no additional data associated with it. The second case, Regular, has additional data of type Rank * Suit, which is a tuple of a Rank and a Suit. We can initialize values of Card by providing the Rank and Suit values associated with the regular card:\nlet joker = Joker let aceOfSpades = Regular(Ace(1), Spades) let tenOfHearts = Regular(Ten(10), Hearts) "},{"id":31,"href":"/fsharp-by-example/chapters/equality/","title":"Structural Equality","parent":"Chapters","content":" Structural Equality in F# vs. Referential Equality in C# In F#, values are compared using structural equality, which means that two values are considered equal if they have the same structure and contain the same data. This is different from the referential equality used in other languages such as C#, where two objects are considered equal only if they refer to the same memory location.\nTo demonstrate this difference, let\u0026rsquo;s compare two F# records using the = operator:\ntype Person = { Name: string; Age: int } let person1 = { Name = \u0026#34;Alice\u0026#34;; Age = 30 } let person2 = { Name = \u0026#34;Alice\u0026#34;; Age = 30 } let areEqual = person1 = person2 // true In this example, person1 and person2 are two different instances of the Person record type, but they have the same structure and data. Therefore, when we compare them using the = operator, we get true.\nOn the other hand, in C#, two objects are considered equal only if they refer to the same memory location, as shown in the following example:\npublic class Person { public string Name { get; set; } public int Age { get; set; } } var person1 = new Person { Name = \u0026#34;Alice\u0026#34;, Age = 30 }; var person2 = new Person { Name = \u0026#34;Alice\u0026#34;, Age = 30 }; var areEqual = person1 == person2; // false In this example, person1 and person2 are two different instances of the Person class, even though they have the same structure and data. Therefore, when we compare them using the == operator, we get false.\n"},{"id":32,"href":"/fsharp-by-example/chapters/pattern-matching/","title":"Pattern Matching","parent":"Chapters","content":"Pattern matching is a powerful feature in functional programming languages that allows you to match a value or data structure against a set of patterns and execute the corresponding code block based on the match. It is a declarative and expressive way of branching code based on data values, and it can be used to simplify complex conditional logic.\nIn F#, pattern matching is a first-class citizen, which means it is deeply integrated into the language syntax and semantics. F# provides a rich set of pattern matching constructs, such as matching on values, tuples, lists, arrays, discriminated unions, and more.\nMatching Values Matching on values is the simplest form of pattern matching, and it involves matching a single value against one or more patterns. Let\u0026rsquo;s say we want to write a function that takes an integer and returns a string representing the parity of the number (even or odd). We can use pattern matching to achieve this as follows:\nlet parity x = match x % 2 with | 0 -\u0026gt; \u0026#34;even\u0026#34; | _ -\u0026gt; \u0026#34;odd\u0026#34; In this example, we define a function parity that takes an integer x. We then use pattern matching to match the result of x % 2 against two patterns: 0 and _. The first pattern matches x % 2 when it is equal to 0, and the second pattern is a wildcard pattern that matches any other value.\nGuard Clauses In addition to matching values against patterns, F# allows us to further refine each case through guard clauses. Guard clauses let us specify additional criteria that must be met to satisfy a case. These criteria can be expressed as Boolean expressions that are checked after a successful match of the pattern.\nTo illustrate, consider the following example, which uses guard clauses to distinguish between positive and negative numbers:\nlet testNumber value = match value with | v when v \u0026lt; 0 -\u0026gt; printfn \u0026#34;%i is negative\u0026#34; v | v when v \u0026gt; 0 -\u0026gt; printfn \u0026#34;%i is positive\u0026#34; v | _ -\u0026gt; printfn \u0026#34;zero\u0026#34; In this example, we have two cases with identical patterns, but different guard clauses. Even though any integer will match any of the three patterns, the guard clauses on patterns v \u0026lt; 0 and v \u0026gt; 0 cause the matching to fail unless the captured value meets their criteria.\nWe can also combine multiple guard clauses with Boolean operators for more complex matching logic. For example, we could construct a case that matches only positive, even integers as follows:\nlet testNumber value = match value with | v when v \u0026gt; 0 \u0026amp;\u0026amp; v % 2 = 0 -\u0026gt; printfn \u0026#34;%i is positive and even\u0026#34; v | v -\u0026gt; printfn \u0026#34;%i is zero, negative, or odd\u0026#34; v In this example, the guard clause v \u0026gt; 0 \u0026amp;\u0026amp; v % 2 = 0 checks whether the value is positive and even. If the guard clause is true, the first pattern is matched, and the corresponding message is printed. Otherwise, the second pattern is matched, and the corresponding message is printed.\nGuard clauses are a powerful feature of F# pattern matching that allow us to add additional conditions to our matching logic, making it more precise and expressive.\n"},{"id":33,"href":"/fsharp-by-example/chapters/matching-functions/","title":"Pattern Matching Functions","parent":"Chapters","content":"Pattern matching functions are an alternative way of writing match expressions in F#. With this syntax, instead of using the match...with structure, you can create a function that takes a value and pattern matches on it using the function keyword.\nFor example, let\u0026rsquo;s say we want to create a function that prints the value of an integer option. We could write it using the pattern-matching function syntax like this:\nlet isPositive = function | x when x \u0026gt; 0 -\u0026gt; printfn \u0026#34;The number %i is positive\u0026#34; x | 0 -\u0026gt; printfn \u0026#34;The number is zero\u0026#34; | _ -\u0026gt; printfn \u0026#34;The number is negative\u0026#34; In this example, we define a function called isPositive that takes one argument. Instead of explicitly defining the argument, we use the function keyword to indicate that we are defining a pattern-matching function. We then define three patterns that are matched against the input value: one for positive numbers, one for zero, and one for negative numbers.\nWe can then call this function with different inputs to see the different results:\nisPositive 10 // Output: The number 10 is positive isPositive 0 // Output: The number is zero isPositive (-5) // Output: The number is negative The advantage of using pattern-matching functions is that they are more concise than regular functions that use match expressions. They also allow you to pass them as arguments to higher-order functions, as shown in the previous examples.\n"},{"id":34,"href":"/fsharp-by-example/chapters/matching-data-structures/","title":"Pattern Matching on Data Structures","parent":"Chapters","content":"Pattern matching is a powerful feature in F# that allows you to extract and work with the values in data structures such as tuples, lists, arrays, discriminated unions, and records. In this chapter, we\u0026rsquo;ll explore how to use pattern matching to work with these data structures.\nMatching on Tuples Matching on tuples allows you to match a tuple against one or more patterns. Let\u0026rsquo;s say we have a function that returns a tuple of two integers, and we want to write a function that takes the tuple and returns the sum of the two integers. We can use pattern matching on tuples as follows:\nlet sumTuple (x, y) = match (x, y) with | (a, b) -\u0026gt; a + b In this example, we define a function sumTuple that takes a tuple of two integers (x, y). We then use pattern matching to match the tuple (x, y) against a pattern of the form (a, b). The pattern binds the values of x and y to a and b, respectively, and then returns their sum.\nMatching on Lists Matching on lists allows you to match a list against one or more patterns. Let\u0026rsquo;s say we want to write a function that takes a list of integers and returns the sum of the even integers. We can use pattern matching on lists as follows:\nlet sumEvens xs = let rec sum acc = function | [] -\u0026gt; acc | x::xs when x % 2 = 0 -\u0026gt; sum (acc + x) xs | _::xs -\u0026gt; sum acc xs sum 0 xs In this example, we define a function sumEvens that takes a list of integers xs. We then define an inner recursive function sum that takes an accumulator acc and a list xs. We use pattern matching to match the list xs against three patterns: [], x::xs when x % 2 = 0, and _::xs. The first pattern matches an empty list and returns the accumulator. The second pattern matches a non-empty list where the head x is even, and it adds x to the accumulator before calling sum recursively on the tail xs. The third pattern matches a non-empty list where the head _ is odd, and it discards the head and calls sum recursively on the tail xs.\nMatching on Discriminated Unions Discriminated Unions (DUs) are often used in F# to model complex data structures. One of the most powerful features of DUs is pattern matching. Pattern matching is a powerful tool that allows you to match values against patterns and perform different actions depending on the pattern that is matched.\nIn F#, you can use pattern matching with DUs to extract the values associated with each case of the DU. Let\u0026rsquo;s take the example of the Sound DU:\ntype Note = | A | ASharp | B | C | CSharp | D | DSharp | E | F | FSharp | G | GSharp type Octave = | One | Two | Three type Sound = | Pause | Tone of Note * Octave We can use pattern matching to extract the values associated with the Tone case:\nlet pause = Pause let tone = Tone(FSharp, Two) match tone with | Tone(note, octave) -\u0026gt; printfn \u0026#34;Note: %A, Octave: %A\u0026#34; note octave | Pause -\u0026gt; printfn \u0026#34;Pause\u0026#34; // Output: Note: FSharp, Octave: Two In this example, we have defined a value of Sound called tone, which is a Tone consisting of a F# note and the second octave. We then use the match keyword to pattern match against the tone value. The first case that we define in the match expression is Tone(note, octave), which matches against any value that is a Tone case of the Sound DU. We then use printfn to print out the note and octave values.\nIf the value of tone is a Pause, the second case of the match expression will match and print out \u0026ldquo;Pause\u0026rdquo; to the console.\nMatching on Records Records are another data structure that can be pattern matched in F#. Let\u0026rsquo;s take the example of the Card record that we defined earlier:\ntype Card = { Suit: Suit; Rank: Rank } We can use pattern matching to extract the Suit and Rank values from a Card:\nlet card = { Suit = Spades; Rank = Ace(1) } match card with | { Suit = suit; Rank = rank } -\u0026gt; printfn \u0026#34;Suit: %A, Rank: %A\u0026#34; suit rank // Output: Suit: Spades, Rank: Ace 1 In this example, we have defined a value of Card called card, which is a Spades Ace. We then use the match keyword to pattern match against the card value. The first case that we define in the match expression is { Suit = suit; Rank = rank }, which matches against any value that is a Card record. We then use printfn to print out the suit and rank values.\nPattern matching on records can be useful when you want to extract specific fields from a record and perform some action on them. It is also useful when working with large records that have many fields, as you can extract only the fields that you need.\nMatching on Arrays Arrays are another data structure that can be pattern matched in F#. Let\u0026rsquo;s say we want to write a function that takes an array of integers and returns the sum of the even integers. We can use pattern matching on arrays as follows:\nlet sumEvens arr = let mutable sum = 0 for i in 0 .. arr.Length - 1 do match arr.[i] with | x when x % 2 = 0 -\u0026gt; sum \u0026lt;- sum + x | _ -\u0026gt; () sum In this example, we define a function sumEvens that takes an array of integers arr. We then define a mutable variable sum to hold the running sum of even integers. We use a for loop to iterate over the array indices, and we use pattern matching to match the value at each index against two patterns: x when x % 2 = 0, which matches even integers and adds them to the sum, and _, which matches all other values and does nothing.\nAfter iterating over all the elements in the array, we return the final value of the sum.\n"},{"id":35,"href":"/fsharp-by-example/chapters/patterns/","title":"Pattern Matching Patterns","parent":"Chapters","content":"Pattern matching is a powerful feature in F# that allows you to match patterns in your data and execute specific code based on the matched pattern. In this chapter, we will explore some common pattern matching patterns in F#.\nWildcard Pattern The wildcard pattern is the simplest pattern and matches anything. You can use the wildcard pattern to match any value or expression. Here\u0026rsquo;s an example:\nlet matchAnything x = match x with | _ -\u0026gt; \u0026#34;Matched anything!\u0026#34; In this example, the matchAnything function takes a single parameter x and uses pattern matching to match any value. The _ in the pattern is the wildcard pattern that matches anything. If the value passed to the function matches the wildcard pattern, the function returns the string \u0026ldquo;Matched anything!\u0026rdquo;.\nAs a more practical example:\nlet listDescription lst = match lst with | [] -\u0026gt; \u0026#34;empty list\u0026#34; | [x] -\u0026gt; \u0026#34;singleton list containing \u0026#34; + x.ToString() | _ -\u0026gt; \u0026#34;list with multiple elements\u0026#34; AND Pattern In F#, the AND pattern allows you to match an input against multiple patterns, by combining them with an ampersand (\u0026amp;). The input must satisfy each pattern on both sides of the AND pattern. The types of both sides must also be compatible.\nOne example of using the AND pattern is to extract values from a tuple when the second or first value is 0, respectively, as shown in the example below:\nlet locatePoint = function | (0, 0) as p -\u0026gt; sprintf \u0026#34;%A is at the origin\u0026#34; p | (x, y) \u0026amp; (_, 0) -\u0026gt; sprintf \u0026#34;(%i, %i) is on the x-axis\u0026#34; x y | (x, y) \u0026amp; (0, _) -\u0026gt; sprintf \u0026#34;(%i, %i) is on the y-axis\u0026#34; x y | (x, y) -\u0026gt; sprintf \u0026#34;Point (%i, %i)\u0026#34; x y In this example, the locatePoint function uses AND patterns to extract the x and y values from a tuple. If the second value is 0, it matches the first pattern (x, y) \u0026amp; (_, 0) and outputs the message \u0026quot;(x, y) is on the x-axis\u0026quot;. Similarly, if the first value is 0, it matches the second pattern (x, y) \u0026amp; (0, _) and outputs the message \u0026quot;(x, y) is on the y-axis)\u0026quot;. If neither value is 0, it matches the third pattern (x, y) and outputs the message \u0026quot;Point (x, y)\u0026quot;.\nOR Pattern The OR pattern is used when input data can match multiple patterns, and you want to execute the same code as a result. The types of both sides of the OR pattern must be compatible. You can combine patterns using the (|) operator to match multiple patterns. For example:\nlet detectZeroOR point = match point with | (0, 0) | (0, _) | (_, 0) -\u0026gt; printfn \u0026#34;Zero found.\u0026#34; | _ -\u0026gt; printfn \u0026#34;Both nonzero.\u0026#34; In this example, the match expression matches points that have either the first or second value equal to zero or both values equal to zero. If the input point matches any of these patterns, the function prints \u0026ldquo;Zero found.\u0026rdquo; Otherwise, it prints \u0026ldquo;Both nonzero.\u0026rdquo;\nCONS Pattern In F#, the cons operator (::) separates a list’s head from its tail. The Cons pattern allows you to recursively match against a list with an arbitrary number of elements.\nThe Cons pattern is used to decompose a list into its first element and the remaining elements. It matches a list with a pattern of the form head :: tail, where head is the first element and tail is the remaining list. The head value can be any pattern, including a wildcard pattern, while tail is a list that may be empty.\nHere\u0026rsquo;s an example of using the Cons pattern to recursively print the elements of a list:\nlet list1 = [1; 2; 3; 4] let rec printList l = match l with | head :: tail -\u0026gt; printf \u0026#34;%d \u0026#34; head; printList tail | [] -\u0026gt; printfn \u0026#34;\u0026#34; printList list1 // output: \u0026#34;1 2 3 4 \u0026#34; In this example, the printList function recursively matches against the input list using the Cons pattern. When the list is non-empty, the head value is printed and the function is called recursively with the tail. When the list is empty, the function terminates.\nThe Cons pattern is often used in recursive functions that operate on lists. For example, you can use the Cons pattern to implement the List.length function:\nlet rec length l = match l with | [] -\u0026gt; 0 | _ :: tail -\u0026gt; 1 + length tail In this implementation, the length function recursively matches against the input list using the Cons pattern. When the list is empty, the function returns 0. When the list is non-empty, the function increments the count and makes a recursive call with the tail.\n"},{"id":36,"href":"/fsharp-by-example/chapters/generics/","title":"Generics","parent":"Chapters","content":"Generics play a vital role in modern programming languages, allowing developers to write code that is flexible, reusable, and type-safe. In F#, generics provide a powerful mechanism for creating functions and types that can work with multiple data types. This chapter explores the fundamentals of generics in F#, demonstrating their importance and providing practical examples of their usage.\nGenerics are not exclusive to F#; other programming languages such as Java and C# also incorporate generics into their syntax and provide similar functionalities. However, F# takes the concept of generics a step further, offering a more expressive and concise approach. F#\u0026rsquo;s functional programming paradigm and powerful type inference mechanism enhance the usability and flexibility of generics, enabling developers to write highly generic and type-safe code with less ceremony. With its support for higher-kinded types and advanced type-level programming techniques, F# empowers developers to explore advanced generic scenarios and achieve greater levels of code reuse and abstraction.\nlet describeValue\u0026lt;\u0026#39;T\u0026gt; (value: \u0026#39;T) : \u0026#39;T * string = value, sprintf \u0026#34;%A\u0026#34; value // Usage examples let result1 = describeValue 42 // Result: (42, \u0026#34;42\u0026#34;) let result2 = describeValue \u0026#34;Hello\u0026#34; // Result: (\u0026#34;Hello\u0026#34;, \u0026#34;\\\u0026#34;Hello\\\u0026#34;\u0026#34;) printfn \u0026#34;Result 1: %A\u0026#34; result1 printfn \u0026#34;Result 2: %A\u0026#34; result2 This example demonstrates a straightforward use of generics by creating a function that can work with values of any type and return results based on the generic type inference. It allows for code reuse and flexibility when dealing with different types.\nThe line let describeValue\u0026lt;'T\u0026gt; (value: 'T) : 'T * string = defines the describeValue function as a generic function. It takes a parameter value of type 'T and returns a tuple of type 'T * string.\n"},{"id":37,"href":"/fsharp-by-example/chapters/generic-functions/","title":"Generic Functions","parent":"Chapters","content":"In F#, you can define generic functions that operate on different types. By using type parameters, you can create functions that are reusable across multiple data types. Let\u0026rsquo;s take a look at an example:\ntype Stack\u0026lt;\u0026#39;T\u0026gt; = \u0026#39;T list let push (item: \u0026#39;T) (stack: Stack\u0026lt;\u0026#39;T\u0026gt;) : Stack\u0026lt;\u0026#39;T\u0026gt; = item :: stack let pop (stack: Stack\u0026lt;\u0026#39;T\u0026gt;) : \u0026#39;T option * Stack\u0026lt;\u0026#39;T\u0026gt; = match stack with | [] -\u0026gt; None, [] | head :: tail -\u0026gt; Some head, tail let emptyStack : Stack\u0026lt;int\u0026gt; = [] let numberStack : Stack\u0026lt;int\u0026gt; = emptyStack |\u0026gt; push 1 |\u0026gt; push 2 |\u0026gt; push 3 let poppedNumber, remainingStack = pop numberStack match poppedNumber with | Some number -\u0026gt; printfn \u0026#34;Popped number: %d\u0026#34; number | None -\u0026gt; printfn \u0026#34;Stack is empty.\u0026#34; In F#, the notation 'T represents a type parameter or type variable. It is a placeholder that can be replaced with an actual type when using the generic type or function. The 'T notation is a common convention, but you can use any valid identifier starting with a single quote (') to represent a type parameter.\nAnother example:\nlet findMaximum\u0026lt;\u0026#39;T when \u0026#39;T : comparison\u0026gt; (list: \u0026#39;T list) = List.max list let numbers = [3; 7; 1; 9; 2] let maximum = findMaximum numbers printfn \u0026#34;The maximum number is %d\u0026#34; maximum In this example, the findMaximum function is defined with a generic type parameter 'T. The 'T represents any type that satisfies the comparison constraint. By using List.max, the function finds the maximum value in the provided list, regardless of the specific type. This demonstrates the power of generics in writing reusable functions.\n"},{"id":38,"href":"/fsharp-by-example/chapters/generic-types/","title":"Generic Types","parent":"Chapters","content":"In addition to generic functions, F# supports the creation of generic types. With generic types, you can define data structures that can work with different types. Let\u0026rsquo;s consider a simple example of a generic linked list implementation:\ntype LinkedList\u0026lt;\u0026#39;T\u0026gt; = | Empty | Node of \u0026#39;T * LinkedList\u0026lt;\u0026#39;T\u0026gt; In this example, we define a generic type LinkedList\u0026lt;'T\u0026gt; that represents a linked list. It can hold elements of any type. The linked list is defined as a discriminated union with two cases:\nEmpty, representing an empty list. Node, representing a node that contains an element of type 'T and a reference to the next node, which is also of type LinkedList\u0026lt;'T\u0026gt;. To demonstrate the usage of the linked list, let\u0026rsquo;s define a function addToFront that adds an item to the front of the list:\nlet addToFront (item: \u0026#39;T) (list: LinkedList\u0026lt;\u0026#39;T\u0026gt;) : LinkedList\u0026lt;\u0026#39;T\u0026gt; = match list with | Empty -\u0026gt; Node(item, Empty) | Node(value, next) -\u0026gt; Node(item, list) The addToFront function takes an item of type \u0026lsquo;T and a LinkedList\u0026lt;\u0026lsquo;T\u0026gt; as parameters. It pattern matches on the list parameter to handle two cases: if the list is empty (Empty case), it creates a new node with the item as its value and an empty list as the next node. If the list is not empty (Node case), it creates a new node with the item as its value and the existing list as the next node.\nHere\u0026rsquo;s an example usage of the addToFront function:\nlet list = Node(3, Node(2, Node(1, Empty))) let updatedList = addToFront 4 list In this example, we create a linked list list with elements 3, 2, and 1. We then use the addToFront function to add the value 4 to the front of the list, resulting in the updated list updatedList.\nBy utilizing generic types like LinkedList\u0026lt;\u0026lsquo;T\u0026gt;, you can create flexible and reusable data structures that work with various types, providing a powerful tool for building generic algorithms and promoting code reuse.\u0026quot;\nThis updated explanation focuses on the generic linked list implementation and includes an example usage of the addToFront function to showcase the functionality of the generic type in a practical scenario.\n"},{"id":39,"href":"/fsharp-by-example/chapters/generic-constraints/","title":"Generic Constraints","parent":"Chapters","content":"Sometimes, we need to apply constraints to our generic types or functions. F# allows you to specify type constraints to ensure that the generic code works with specific interfaces or base types. Let\u0026rsquo;s look at an example of a generic function that requires the IComparable constraint:\nlet findSmallest\u0026lt;\u0026#39;T when \u0026#39;T :\u0026gt; System.IComparable\u0026lt;\u0026#39;T\u0026gt;\u0026gt; (list: \u0026#39;T list) = List.min list let names = [\u0026#34;Alice\u0026#34;; \u0026#34;Bob\u0026#34;; \u0026#34;Charlie\u0026#34;; \u0026#34;David\u0026#34;] let smallest = findSmallest names printfn \u0026#34;The smallest name is %s\u0026#34; smallest In F#, the :\u0026gt; operator is used to specify a type constraint known as upcasting. It allows you to constrain a generic type parameter to a specific type or its base type. The :\u0026gt; operator indicates that the type parameter must be a subtype of or the same type as the specified type constraint.\nIn this example, the findSmallest function finds the smallest value in the provided list. The 'T type parameter is constrained with System.IComparable\u0026lt;'T\u0026gt;, ensuring that the elements in the list are comparable. This constraint enables the use of the List.min function, which requires comparable elements.\nAnother example would be:\nlet inline addValues\u0026lt;\u0026#39;T when \u0026#39;T : (static member (+) : \u0026#39;T * \u0026#39;T -\u0026gt; \u0026#39;T)\u0026gt; (a: \u0026#39;T) (b: \u0026#39;T) : \u0026#39;T = a + b The function addValues is a generic function in F# that performs addition on two values of the same type. Let\u0026rsquo;s break down its different components:\nlet inline addValues\u0026lt;'T when 'T : (static member (+) : 'T * 'T -\u0026gt; 'T)\u0026gt; (a: 'T) (b: 'T) : 'T = This is the function signature. It declares a function named addValues with a generic type parameter 'T. The 'T type parameter has a constraint specified using the when keyword. The constraint 'T : (static member (+) : 'T * 'T -\u0026gt; 'T) ensures that the generic type 'T supports a static member named +, which takes two arguments of type 'T and returns a value of type 'T. The function takes two parameters a and b, both of type 'T, and returns a value of type 'T. inline keyword: The inline keyword is used to enable inlining of the function at the call site. It instructs the F# compiler to generate specialized code for each usage of the function with specific types. Inlining eliminates the overhead of function calls and allows for more efficient code execution. It can improve performance but also increases the size of the compiled code. In this case, the inline keyword is necessary because the function has a static member constraint. It enables the compiler to generate specialized code for each type that satisfies the constraint. static member constraint: The static member constraint specifies that the generic type 'T must have a static member with a specific signature. This constraint allows the function to use the + operator on values of type 'T inside the function body, knowing that the operator is supported for the given type. So, the addValues function is a generic function that performs addition (+) on two values of the same type 'T. The inline keyword is necessary to enable inlining and generate specialized code for each type used at the call site. The static member constraint ensures that the generic type 'T supports the + operator with the specified signature.\nThis can be called with different parameter types:\nlet sum1 = addValues 5 3 // Result: 8 let sum2 = addValues 2.5 1.75 // Result: 4.25 let concatenatedString = addValues \u0026#34;Hello, \u0026#34; \u0026#34;world!\u0026#34; // Result: \u0026#34;Hello, world!\u0026#34; Generics are a powerful feature in F# that allow you to write flexible and reusable code. By using generic functions and types, you can write code that works with various data types without sacrificing type safety. Through examples, we have explored the basics of generics in F#, including generic functions, generic types, constraints, and type inference. Armed with this knowledge, you can leverage generics to write more maintainable and adaptable F# code in your projects.\n"},{"id":40,"href":"/fsharp-by-example/chapters/option/","title":"Option","parent":"Chapters","content":"In functional programming, handling optional values and potential absence of data is a common scenario. F#, a functional-first programming language, provides a powerful type called Option to address this need.\nImagine that you have created a function that searches for a user in the database, and there are only two possible outcomes:\nThe user was found. The user was not found. If the result of our function needs to be fully included in the return type of the function, then we need a type that represents this optional value. In F#, this type is called Option, for create an Option Type:\nUse Some constructor with some value; Use None constructor. For example we will create firstOdd function that takes a list of integers xs - a list of integers - as input and returns the Option containing:\nSome containing first odd number found in the list. If no odd number is found, it returns None. let firstOdd xs = List.tryPick (fun x -\u0026gt; if x % 2 = 1 then Some x else None) xs This will works as:\nfirstOdd [2;4;6] // will return =\u0026gt; int option = None firstOdd [2;4;5;6;7] // will return =\u0026gt; int option = Some 5 Note that Option is the generic 'a option that was infered as int option.\n"},{"id":41,"href":"/fsharp-by-example/chapters/pattern-matching-option/","title":"Pattern Matching with Option","parent":"Chapters","content":"Pattern matching is a fundamental technique in F# to handle Option values. It allows us to determine whether a value is present or absent and to destructure the value when it is present. Pattern matching helps us handle both Some and None cases effectively.\nLet\u0026rsquo;s take an example:\nlet divide x y = if y \u0026lt;\u0026gt; 0 then Some (x / y) else None This will work as:\ndivide 5 6 // will return =\u0026gt; int option = Some 0 divide 5 0 // will return =\u0026gt; int option = None This is an example of how it can be convenient to handle errors. Usually 5 / 0 would return a System.DivideByZeroException but with Option we can handle it without an exception.\n"},{"id":42,"href":"/fsharp-by-example/chapters/handling-errors-option/","title":"Handling Errors with Option","parent":"Chapters","content":"Option is commonly used for error handling in F#. As we seen in the Pattern Matching part, we can instead of throwing exceptions, which can disrupt the flow of functional programming, use Option with Pattern Matching to handle errors gracefully. This helps us write more robust and predictable code.\nFor instance, let\u0026rsquo;s say we want to parse a string into an integer:\nlet parseInteger (str: string) : int option = match System.Int32.TryParse(str) with | (true, value) -\u0026gt; Some value | _ -\u0026gt; None This will work as:\nparseInteger \u0026#34;42\u0026#34; // will return =\u0026gt; int option = Some 42 parseInteger \u0026#34;abc\u0026#34; // will return =\u0026gt; int option = None The parseInteger function attempts to parse a string into an integer using System.Int32.TryParse. If the parsing is successful, it returns Some with the parsed value; otherwise, it returns None.\nBy leveraging pattern matching, chaining operations, and handling errors gracefully, you can write more robust and concise code. Understanding and effectively using Option is essential for mastering functional programming in F#.\n"},{"id":43,"href":"/fsharp-by-example/chapters/","title":"Chapters","parent":"F# by Example","content":""},{"id":44,"href":"/fsharp-by-example/","title":"F# by Example","parent":"","content":"Welcome to F# by example, the go-to resource for anyone looking to learn F# programming from scratch or to sharpen their skills.\nOur tutorial covers a wide range of topics, from the basics of functional programming to advanced techniques for building high-quality software. We provide practical, hands-on examples that are easy to follow and understand, along with code snippets, illustrations, and interactive exercises.\nWhy F#? F# is a powerful and versatile programming language that combines functional and object-oriented programming paradigms. It offers a range of features that make it ideal for developing complex software systems, including expressive syntax, type inference, pattern matching, and immutable data structures.\nAt the same time, F# is easy to learn and use, thanks to its clear and concise syntax and strong community support. Whether you\u0026rsquo;re a seasoned developer or a beginner, F# is a great choice for building robust, scalable, and maintainable software.\nWhat You\u0026rsquo;ll Learn Our tutorial covers all the essential topics you need to know to get started with F#, including:\nBasic syntax and data types Functions and higher-order functions Pattern matching and recursion Immutable data structures, such as lists, arrays, and tuples Who Is This Tutorial For? F# by example is designed for anyone who wants to learn functional programming or improve their existing F# skills. Whether you\u0026rsquo;re a student, a professional developer, or a hobbyist, our tutorial provides a comprehensive and engaging introduction to F# programming.\nGet Started Today Ready to start your journey into F# programming? Head over to our first chapter, \u0026ldquo;Hello World\u0026rdquo;, and dive in. Our tutorial is free and open source, and you can read it online or download it in various formats. Join our community of F# enthusiasts and learn to build elegant, efficient, and expressive software with F# by example.\n"},{"id":45,"href":"/fsharp-by-example/tags/","title":"Tags","parent":"F# by Example","content":""}]